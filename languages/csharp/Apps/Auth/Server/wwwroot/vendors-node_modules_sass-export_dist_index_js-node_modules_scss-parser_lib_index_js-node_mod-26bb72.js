/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendors-node_modules_sass-export_dist_index_js-node_modules_scss-parser_lib_index_js-node_mod-26bb72";
exports.ids = ["vendors-node_modules_sass-export_dist_index_js-node_modules_scss-parser_lib_index_js-node_mod-26bb72"];
exports.modules = {

/***/ "../../node_modules/sass-export/dist/app/converter/converter-buffer.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/sass-export/dist/app/converter/converter-buffer.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConverterBuffer = void 0;\nconst converter_1 = __webpack_require__(/*! ./converter */ \"../../node_modules/sass-export/dist/app/converter/converter.js\");\nconst Types = {\n    STRUCTURED: 'structured',\n    ARRAY: 'array'\n};\nclass ConverterBuffer extends converter_1.Converter {\n    constructor(inputBuffers, options) {\n        super(options);\n        this.inputBuffers = inputBuffers;\n    }\n    getData() {\n        if (this.options && this.options.type === Types.ARRAY) {\n            return Promise.resolve(this.getArray());\n        }\n        else {\n            return Promise.resolve(this.getStructured());\n        }\n    }\n    getContent() {\n        let contents = this.inputBuffers.map((buffer) => buffer.toString());\n        return contents.join('\\n');\n    }\n}\nexports.ConverterBuffer = ConverterBuffer;\n//# sourceMappingURL=converter-buffer.js.map\n\n//# sourceURL=webpack://blazor-app/../../node_modules/sass-export/dist/app/converter/converter-buffer.js?");

/***/ }),

/***/ "../../node_modules/sass-export/dist/app/converter/converter.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/sass-export/dist/app/converter/converter.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Converter = void 0;\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst sass = __webpack_require__(/*! sass */ \"../../node_modules/sass/sass.dart.js\");\nconst glob = __webpack_require__(/*! glob */ \"../../node_modules/glob/glob.js\");\nconst parser_1 = __webpack_require__(/*! ../parser */ \"../../node_modules/sass-export/dist/app/parser/index.js\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"../../node_modules/sass-export/dist/app/utils/index.js\");\nconst LINE_BREAK = '\\n';\nclass Converter {\n    constructor(options) {\n        this.options = options;\n        this.options = options || {};\n    }\n    getArray() {\n        let content = this.getContent();\n        let parsedDeclarations = new parser_1.Parser(content).parse();\n        return parsedDeclarations.map((declaration) => {\n            let isMap = false;\n            if (declaration.mapValue) {\n                isMap = true;\n            }\n            declaration.compiledValue = this.renderPropertyValue(content, declaration, isMap);\n            declaration.name = `$${declaration.name}`;\n            if (declaration.mapValue) {\n                declaration.mapValue.map((mapDeclaration) => {\n                    mapDeclaration.compiledValue = this.renderPropertyValue(content, mapDeclaration, true);\n                    return mapDeclaration;\n                });\n            }\n            return declaration;\n        });\n    }\n    getStructured() {\n        let content = this.getContent();\n        let structuredDeclaration = new parser_1.Parser(content).parseStructured();\n        structuredDeclaration = this.compileStructure(structuredDeclaration);\n        return structuredDeclaration;\n    }\n    compileStructure(structuredDeclaration) {\n        let groups = Object.keys(structuredDeclaration);\n        groups.forEach((group) => {\n            let content = this.getContent();\n            let isMap = false;\n            let compiledGroup = structuredDeclaration[group].map((declaration) => {\n                if (declaration.mapValue) {\n                    isMap = true;\n                }\n                declaration.compiledValue = this.renderPropertyValue(content, declaration, isMap);\n                declaration.name = `$${declaration.name}`;\n                if (declaration.mapValue) {\n                    declaration.mapValue.map((mapDeclaration) => {\n                        mapDeclaration.compiledValue = this.renderPropertyValue(content, mapDeclaration, true);\n                        return mapDeclaration;\n                    });\n                }\n                return declaration;\n            });\n        });\n        return this.checkForMixins(structuredDeclaration);\n    }\n    getContent() {\n        let inputFiles = [];\n        let inputs = [];\n        if (!Array.isArray(this.options.inputFiles)) {\n            inputFiles.push(this.options.inputFiles);\n        }\n        else {\n            inputFiles = this.options.inputFiles;\n        }\n        inputFiles.forEach((path) => {\n            let files = glob.sync(String(path));\n            inputs.push(...files);\n        });\n        let contents = inputs.map((filePath) => fs.readFileSync(String(filePath)));\n        return contents.join(LINE_BREAK);\n    }\n    checkForMixins(structuredDeclaration) {\n        let mixinsGroup = 'mixins';\n        let parsedMixins = new parser_1.Mixins(this.getContent()).parse();\n        if (parsedMixins && parsedMixins.length) {\n            structuredDeclaration[mixinsGroup] = parsedMixins;\n        }\n        return structuredDeclaration;\n    }\n    renderPropertyValue(content, declaration, isMap) {\n        try {\n            let rendered = sass.renderSync({\n                data: content + LINE_BREAK + utils_1.Utils.wrapCss(declaration, isMap),\n                includePaths: this.options.includePaths,\n                outputStyle: 'compressed'\n            });\n            let wrappedRendered = String(rendered.css);\n            wrappedRendered = utils_1.Utils.removeDoubleQuotes(wrappedRendered);\n            return utils_1.Utils.unWrapValue(wrappedRendered);\n        }\n        catch (err) {\n            console.error(err);\n            return '';\n        }\n    }\n}\nexports.Converter = Converter;\n//# sourceMappingURL=converter.js.map\n\n//# sourceURL=webpack://blazor-app/../../node_modules/sass-export/dist/app/converter/converter.js?");

/***/ }),

/***/ "../../node_modules/sass-export/dist/app/converter/index.js":
/*!******************************************************************!*\
  !*** ../../node_modules/sass-export/dist/app/converter/index.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./converter */ \"../../node_modules/sass-export/dist/app/converter/converter.js\"), exports);\n__exportStar(__webpack_require__(/*! ./converter-buffer */ \"../../node_modules/sass-export/dist/app/converter/converter-buffer.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://blazor-app/../../node_modules/sass-export/dist/app/converter/index.js?");

/***/ }),

/***/ "../../node_modules/sass-export/dist/app/parser/index.js":
/*!***************************************************************!*\
  !*** ../../node_modules/sass-export/dist/app/parser/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./parser */ \"../../node_modules/sass-export/dist/app/parser/parser.js\"), exports);\n__exportStar(__webpack_require__(/*! ./mixins */ \"../../node_modules/sass-export/dist/app/parser/mixins.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://blazor-app/../../node_modules/sass-export/dist/app/parser/index.js?");

/***/ }),

/***/ "../../node_modules/sass-export/dist/app/parser/mixins.js":
/*!****************************************************************!*\
  !*** ../../node_modules/sass-export/dist/app/parser/mixins.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Mixins = void 0;\nconst MIXIN_VALUES_REGEX = /@mixin ?((?!\\d)[\\w_-][\\w\\d_-]*)(\\([^\\)\"]+.)?/gi;\nconst FUNC_VALUES_REGEX = /@function ?((?!\\d)[\\w_-][\\w\\d_-]*)(\\([^\\)\"]+.)?/gi;\nconst MIXIN_DECLARATION_REGEX = '@mixin.[^\\{]+|@function.[^\\{]+';\nclass Mixins {\n    constructor(rawContent) {\n        this.rawContent = rawContent;\n    }\n    parse() {\n        let matches = this.extractDeclarations(this.rawContent);\n        let declarations = [];\n        matches.forEach((match) => {\n            let mixins = this.parseSingle(match);\n            let functions = this.parseSingle(match, true);\n            if (mixins) {\n                declarations.push(mixins);\n            }\n            if (functions) {\n                declarations.push(functions);\n            }\n        });\n        return declarations;\n    }\n    extractDeclarations(content) {\n        let matches = content.match(new RegExp(MIXIN_DECLARATION_REGEX, 'gi'));\n        if (!matches) {\n            return [];\n        }\n        return matches;\n    }\n    parseSingle(declaration, checkFunctions = false) {\n        let regex = checkFunctions ? FUNC_VALUES_REGEX : MIXIN_VALUES_REGEX;\n        let matches = (new RegExp(regex, 'gi')).exec(declaration);\n        if (!matches) {\n            return null;\n        }\n        let name = matches[1].trim();\n        let parameters = [];\n        if (matches.length > 2 && matches[2]) {\n            let params = matches[2].split(',').map((param) => param.trim().replace(/[\\(\\)]/g, ''));\n            parameters.push(...params);\n        }\n        return { name, parameters };\n    }\n}\nexports.Mixins = Mixins;\n//# sourceMappingURL=mixins.js.map\n\n//# sourceURL=webpack://blazor-app/../../node_modules/sass-export/dist/app/parser/mixins.js?");

/***/ }),

/***/ "../../node_modules/sass-export/dist/app/parser/parser.js":
/*!****************************************************************!*\
  !*** ../../node_modules/sass-export/dist/app/parser/parser.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Parser = void 0;\nconst VARIABLE_PATERN = '(?!\\\\d)[\\\\w_-][\\\\w\\\\d_-]*';\nconst VALUE_PATERN = '[^;]+|\"(?:[^\"]+|(?:\\\\\\\\\"|[^\"])*)\"';\nconst DECLARATION_PATTERN = `\\\\$['\"]?(${VARIABLE_PATERN})['\"]?\\\\s*:\\\\s*(${VALUE_PATERN})(?:\\\\s*!(global|default)\\\\s*;|\\\\s*;(?![^\\\\{]*\\\\}))`;\nconst MAP_DECLARATIOM_REGEX = /['\"]?((?!\\d)[\\w_-][\\w\\d_-]*)['\"]?\\s*:\\s*([a-z\\-]+\\([^\\)]+\\)|[^\\),\\/]+)/gi;\nconst QUOTES_PATTERN = /^(['\"]).*\\1$/;\nconst QUOTES_REPLACE = /^(['\"])|(['\"])$/g;\nconst SECTION_TAG = 'sass-export-section';\nconst SECTION_PATTERN = `(@${SECTION_TAG}=)(\".+\")`;\nconst END_SECTION_PATTERN = `(@end-${SECTION_TAG})`;\nconst DEFAULT_SECTION = 'variables';\nclass Parser {\n    constructor(rawContent) {\n        this.rawContent = rawContent;\n    }\n    parse() {\n        let matches = this.extractDeclarations(this.rawContent);\n        let declarations = [];\n        for (let match of matches) {\n            if (!this.checkIsSectionStart(match) && !this.checkIsSectionStart(match)) {\n                let parsed = this.parseSingleDeclaration(match);\n                if (parsed) {\n                    let map = this.extractMapDeclarations(parsed.value);\n                    if (map.length) {\n                        parsed.mapValue = map.map((declaration) => this.parseSingleDeclaration(`$${declaration};`));\n                    }\n                    declarations.push(parsed);\n                }\n            }\n        }\n        return declarations;\n    }\n    parseStructured() {\n        let matches = this.extractDeclarationsStructured(this.rawContent);\n        let currentSection = DEFAULT_SECTION;\n        let declarations = {};\n        if (!matches || !matches.length) {\n            return {};\n        }\n        declarations[currentSection] = [];\n        for (let match of matches) {\n            if (this.checkIsSectionStart(match)) {\n                let sectionName = String(new RegExp(SECTION_PATTERN, 'gi').exec(match)[2]);\n                if (sectionName) {\n                    currentSection = sectionName.replace(/\"/g, '');\n                    declarations[currentSection] = declarations[currentSection] || [];\n                }\n            }\n            else if (this.checkIsSectionEnd(match)) {\n                currentSection = DEFAULT_SECTION;\n            }\n            else {\n                let parsed = this.parseSingleDeclaration(match);\n                if (parsed) {\n                    let map = this.extractMapDeclarations(parsed.value);\n                    if (map.length) {\n                        parsed.mapValue = map.map((declaration) => this.parseSingleDeclaration(`$${declaration};`));\n                    }\n                    declarations[currentSection].push(parsed);\n                }\n            }\n        }\n        return declarations;\n    }\n    extractDeclarationsStructured(content) {\n        const matches = content.match(new RegExp(`${DECLARATION_PATTERN}|${SECTION_PATTERN}|${END_SECTION_PATTERN}`, 'g'));\n        if (!matches) {\n            return [];\n        }\n        return matches;\n    }\n    extractDeclarations(content) {\n        const matches = content.match(new RegExp(DECLARATION_PATTERN, 'g'));\n        if (!matches) {\n            return [];\n        }\n        return matches;\n    }\n    extractMapDeclarations(content) {\n        const matches = content.match(new RegExp(MAP_DECLARATIOM_REGEX, 'g'));\n        if (!matches) {\n            return [];\n        }\n        return matches;\n    }\n    parseSingleDeclaration(matchDeclaration) {\n        let matches = matchDeclaration\n            .replace(/\\s*!(default|global)\\s*;/, ';')\n            .match(new RegExp(DECLARATION_PATTERN));\n        if (!matches) {\n            return;\n        }\n        let name = matches[1].trim().replace('_', '-');\n        let value = matches[2].trim().replace(/\\s*\\n+\\s*/g, ' ');\n        if (value.match(QUOTES_PATTERN)) {\n            value = value.replace(QUOTES_REPLACE, '');\n        }\n        return { name, value };\n    }\n    checkIsSectionStart(content) {\n        return (new RegExp(SECTION_PATTERN, 'gi')).test(content);\n    }\n    checkIsSectionEnd(content) {\n        return (new RegExp(END_SECTION_PATTERN, 'gi')).test(content);\n    }\n}\nexports.Parser = Parser;\n//# sourceMappingURL=parser.js.map\n\n//# sourceURL=webpack://blazor-app/../../node_modules/sass-export/dist/app/parser/parser.js?");

/***/ }),

/***/ "../../node_modules/sass-export/dist/app/utils/index.js":
/*!**************************************************************!*\
  !*** ../../node_modules/sass-export/dist/app/utils/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./utils */ \"../../node_modules/sass-export/dist/app/utils/utils.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://blazor-app/../../node_modules/sass-export/dist/app/utils/index.js?");

/***/ }),

/***/ "../../node_modules/sass-export/dist/app/utils/utils.js":
/*!**************************************************************!*\
  !*** ../../node_modules/sass-export/dist/app/utils/utils.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Utils = void 0;\nconst WRAPPER_CSS_ID = '#sass-export-id';\nconst UNWRAPPER_PATTERN = `${WRAPPER_CSS_ID}\\\\.(.+)\\\\s*\\\\{\\\\s*content:\\\\s*[\"'](.+)[\"']`;\nclass Utils {\n    static getDeclarationByName(declarations = [], name) {\n        let filtered = declarations.filter((declaration) => declaration.name === name);\n        return filtered[0];\n    }\n    static wrapCss(cssDeclaration, useInspect) {\n        if (useInspect) {\n            return `${WRAPPER_CSS_ID}.${cssDeclaration.name}{content:\"#{inspect(${cssDeclaration.value})}\";}`;\n        }\n        return `${WRAPPER_CSS_ID}.${cssDeclaration.name}{content:\"#{${cssDeclaration.value}}\";}`;\n    }\n    static removeDoubleQuotes(wrappedContent) {\n        wrappedContent = wrappedContent.replace(/\"([^'\"]+(?=\"'))\"/, '$1');\n        return wrappedContent;\n    }\n    static unWrapValue(wrappedContent) {\n        wrappedContent = wrappedContent.replace(/\\n/g, '');\n        let matches = wrappedContent.match(UNWRAPPER_PATTERN);\n        if (matches && matches.length > 2) {\n            return matches[2].trim();\n        }\n        else {\n            return '';\n        }\n    }\n}\nexports.Utils = Utils;\n//# sourceMappingURL=utils.js.map\n\n//# sourceURL=webpack://blazor-app/../../node_modules/sass-export/dist/app/utils/utils.js?");

/***/ }),

/***/ "../../node_modules/sass-export/dist/index.js":
/*!****************************************************!*\
  !*** ../../node_modules/sass-export/dist/index.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst converter_1 = __webpack_require__(/*! ./app/converter */ \"../../node_modules/sass-export/dist/app/converter/index.js\");\nlet sassExporter = (options) => {\n    return new converter_1.Converter(options);\n};\nlet bufferExporter = (input, options) => {\n    let converter = new converter_1.ConverterBuffer(input, options);\n    return converter.getData();\n};\nmodule.exports = {\n    exporter: sassExporter,\n    buffer: bufferExporter\n};\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://blazor-app/../../node_modules/sass-export/dist/index.js?");

/***/ }),

/***/ "../../node_modules/scss-parser/lib/index.js":
/*!***************************************************!*\
  !*** ../../node_modules/scss-parser/lib/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\nCopyright (c) 2016, salesforce.com, inc. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of salesforce.com, inc. nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\nconst createInputStream = __webpack_require__(/*! ./input-stream */ \"../../node_modules/scss-parser/lib/input-stream.js\")\nconst createTokenStream = __webpack_require__(/*! ./token-stream */ \"../../node_modules/scss-parser/lib/token-stream.js\")\n\nconst _parse = __webpack_require__(/*! ./parse */ \"../../node_modules/scss-parser/lib/parse.js\")\nconst _stringify = __webpack_require__(/*! ./stringify */ \"../../node_modules/scss-parser/lib/stringify.js\")\n\n/**\n * Parse the proivded input as a @{link Node}\n *\n * @param {string} css\n * @returns {Node}\n */\nconst parse = css => _parse(createTokenStream(createInputStream(css)))\n\n/**\n * Convert a @{link Node} back into a stirng\n *\n * @param {Node} node\n * @returns {string}\n */\nconst stringify = node => _stringify(node)\n\nmodule.exports = {\n  parse,\n  stringify\n}\n\n\n//# sourceURL=webpack://blazor-app/../../node_modules/scss-parser/lib/index.js?");

/***/ }),

/***/ "../../node_modules/scss-parser/lib/input-stream.js":
/*!**********************************************************!*\
  !*** ../../node_modules/scss-parser/lib/input-stream.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\nCopyright (c) 2016, salesforce.com, inc. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of salesforce.com, inc. nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* eslint-disable camelcase */\n\nconst _ = __webpack_require__(/*! lodash */ \"../../node_modules/lodash/lodash.js\")\n\n/*\n * @typedef {object} InputStream~Position\n * @property {number} cursor\n * @property {number} line\n * @property {number} column\n */\n\n/**\n * Yield characters from a string\n *\n * @protected\n * @class\n */\nclass InputStream {\n  /**\n   * Create a new InputStream\n   *\n   * @param {string} input\n   */\n  constructor (input) {\n    this.input = input\n    this.cursor = 0\n    this.line = 1\n    this.column = 0\n  }\n\n  /**\n   * Return an object that contains the currrent cursor, line, and column\n   *\n   * @public\n   * @returns {InputStream~Position}\n   */\n  position () {\n    return Object.freeze({\n      cursor: this.cursor,\n      line: this.line,\n      column: this.column\n    })\n  }\n\n  /**\n   * Return the current character with an optional offset\n   *\n   * @public\n   * @param {number} offset\n   * @returns {string}\n   */\n  peek (offset) {\n    const cursor = _.isInteger(offset)\n      ? this.cursor + offset : this.cursor\n    return this.input.charAt(cursor)\n  }\n\n  /**\n   * Return the current character and advance the cursor\n   *\n   * @public\n   * @returns {string}\n   */\n  next () {\n    const c = this.input.charAt(this.cursor++)\n    if (c === '\\n') {\n      this.line++\n      this.column = 0\n    } else {\n      this.column++\n    }\n    return c\n  }\n\n  /**\n   * Return true if the stream has reached the end\n   *\n   * @public\n   * @returns {boolean}\n   */\n  eof () {\n    return this.peek() === ''\n  }\n\n  /**\n   * Throw an error at the current line/column\n   *\n   * @public\n   * @param {string} message\n   * @throws Error\n   */\n  err (msg) {\n    throw new Error(`${msg} (${this.line}:${this.column})`)\n  }\n}\n\n/**\n * @function createInputStreamP\n * @private\n * @param {string} input\n * @returns {InputStreamProxy}\n */\nmodule.exports = (input) => {\n  const i = new InputStream(input)\n  /**\n   * @namespace\n   * @borrows InputStream#position as #position\n   * @borrows InputStream#peek as #peek\n   * @borrows InputStream#next as #next\n   * @borrows InputStream#eof as #eof\n   * @borrows InputStream#err as #err\n   */\n  const InputStreamProxy = {\n    position () {\n      return i.position()\n    },\n    peek () {\n      return i.peek(...arguments)\n    },\n    next () {\n      return i.next()\n    },\n    eof () {\n      return i.eof()\n    },\n    err () {\n      return i.err(...arguments)\n    }\n  }\n  return InputStreamProxy\n}\n\n\n//# sourceURL=webpack://blazor-app/../../node_modules/scss-parser/lib/input-stream.js?");

/***/ }),

/***/ "../../node_modules/scss-parser/lib/parse.js":
/*!***************************************************!*\
  !*** ../../node_modules/scss-parser/lib/parse.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\nCopyright (c) 2016, salesforce.com, inc. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of salesforce.com, inc. nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* eslint-disable camelcase */\n\nconst _ = __webpack_require__(/*! lodash */ \"../../node_modules/lodash/lodash.js\")\nconst invariant = __webpack_require__(/*! invariant */ \"../../node_modules/invariant/invariant.js\")\n\n/*\n * @typedef {object} Node\n * @property {string} type\n * @property {string|array} value\n * @property {InputStream~Position} start\n * @property {InputStream~Position} next\n */\n\n/**\n * Convert a @{link TokenStreamProxy} to a @{link Node}\n *\n * @protected\n * @class\n */\nclass Parser {\n  /**\n   * Create a new InputStream\n   *\n   * @param {TokenStreamProxy} tokens\n   */\n  constructor (tokens) {\n    this.tokens = tokens\n  }\n\n  /**\n   * Return a new @{link Node}\n   *\n   * @private\n   * @param {string} type\n   * @param {string|array} value\n   * @param {InputStream~Position} start\n   * @param {InputStream~Position} next\n   * @returns {Node}\n   */\n  createNode (type, value, start, next) {\n    return { type, value, start, next }\n  }\n\n  /**\n   * Return true if the current token(s) are of the provided type\n   * and optionally match the specific character(s)\n   *\n   * @private\n   * @param {string} type\n   * @param {...string} values\n   * @returns {boolean}\n   */\n  is_type (type, ...values) {\n    const t = this.tokens.peek()\n    if (!values.length) return t ? type.test(t.type) : false\n    return values.reduce((a, c, i) => {\n      const t = this.tokens.peek(i)\n      return !t ? false : a && type.test(t.type) && t.value === c\n    }, true)\n  }\n\n  /**\n   * Return true if the current token is a space\n   *\n   * @private\n   * @returns {boolean}\n   */\n  is_space () {\n    return this.is_type(/space/)\n  }\n\n  /**\n   * Return true if the current token is a comment\n   *\n   * @private\n   * @returns {boolean}\n   */\n  is_comment () {\n    return this.is_type(/comment/)\n  }\n\n  /**\n   * Return true if the current token is a punctuation\n   *\n   * @private\n   * @returns {boolean}\n   */\n  is_punctuation () {\n    return this.is_type(/punctuation/, ...arguments)\n  }\n\n  /**\n   * Return true if the current token is an operator\n   *\n   * @private\n   * @returns {boolean}\n   */\n  is_operator () {\n    return this.is_type(/operator/, ...arguments)\n  }\n\n  /**\n   * Return true if the current token is an identifier\n   *\n   * @private\n   * @returns {boolean}\n   */\n  is_identifier () {\n    return this.is_type(/identifier/, ...arguments)\n  }\n\n  /**\n   * Return true if the current token is an atkeyword\n   *\n   * @private\n   * @returns {boolean}\n   */\n  is_atkeyword () {\n    return this.is_type(/atkeyword/, ...arguments)\n  }\n\n  /**\n   * Return true if the current tokens are interpolation\n   *\n   * @private\n   * @returns {boolean}\n   */\n  is_interpolation () {\n    return this.is_punctuation('#', '{')\n  }\n\n  /**\n   * Return the current and next token if the isType predicate succeeds\n   *\n   * @private\n   * @param {string} type\n   * @param {function} isType\n   * @param {...string} chars\n   * @throws Error\n   * @returns {boolean}\n   */\n  skip_type (type, isType, ...chars) {\n    if (isType.apply(this, chars)) {\n      return { start: this.tokens.peek(), next: this.tokens.next() }\n    } else {\n      this.tokens.err(`Expecting ${type}: \"${chars.join('')}\"`)\n    }\n  }\n\n  /**\n   * Expect a punctuation token optionally of the specified type\n   *\n   * @private\n   * @param (...string) chars\n   * @throws Error\n   * @returns {boolean}\n   */\n  skip_punctuation () {\n    return this.skip_type('punctuation', this.is_punctuation, ...arguments)\n  }\n\n  /**\n   * Expect an operator token optionally of the specified type\n   *\n   * @private\n   * @param (...string) chars\n   * @throws Error\n   * @returns {boolean}\n   */\n  skip_operator () {\n    return this.skip_type('operator', this.is_operator, ...arguments)\n  }\n\n  /**\n   * Expect an atkeyword token\n   *\n   * @private\n   * @throws Error\n   * @returns {boolean}\n   */\n  skip_atkeyword () {\n    return this.skip_type('atkeyword', this.is_atkeyword)\n  }\n\n  /**\n   * Throw an error at the current token\n   *\n   * @private\n   * @throws Error\n   */\n  unexpected () {\n    this.tokens.err(`Unexpected token: \"${JSON.stringify(this.input.peek())}\"`)\n  }\n\n  /**\n   * Return a top level stylesheet Node\n   *\n   * @public\n   * @returns {Node}\n   */\n  parse_stylesheet () {\n    const value = []\n    while (!this.tokens.eof()) {\n      const node = this.parse_node()\n      if (_.isArray(node)) {\n        value.push(...node)\n      } else {\n        value.push(node)\n      }\n    }\n    return this.createNode('stylesheet', value)\n  }\n\n  /**\n   * Parse a top-level Node (atrule,rule,declaration,comment,space)\n   *\n   * @private\n   * @returns {Node|Node[]}\n   */\n  parse_node () {\n    if (\n      this.is_space() || this.is_comment()\n    ) return this.tokens.next()\n\n    const value = []\n\n    const maybe_declaration = (punctuation) => {\n      let expandedPseudo = false\n      // If the declaration ends with a \";\" expand the first pseudo_class\n      // because pseudo_class can't be part of a declaration property\n      if (punctuation === ';') {\n        const pseudoIndex = _.findIndex(value, {\n          type: 'pseudo_class'\n        })\n        if (pseudoIndex > 0) {\n          const a = value[pseudoIndex]\n          const b = this.createNode('punctuation', ':', a.start, _.first(a.value).start)\n          const nodes = [b].concat(a.value)\n          value.splice(pseudoIndex, 1, ...nodes)\n          expandedPseudo = true\n        }\n      }\n      // Try to find a \":\"\n      const puncIndex = _.findIndex(value, {\n        type: 'punctuation',\n        value: ':'\n      })\n      // If we found a \":\"\n      if (puncIndex >= 0) {\n        const maybeSpace = value[puncIndex + 1]\n        // If we found a space, it wasn't a pseudo class selector,\n        // so parse it as a declaration\n        // http://www.sassmeister.com/gist/0e60f53033a44b9e5d99362621143059\n        if (maybeSpace.type === 'space' || expandedPseudo) {\n          const start = _.first(value).start\n          let next = _.last(value).next\n          const property_ = _.take(value, puncIndex)\n          const propertyNode = this.createNode(\n            'property', property_, _.first(property_).start, _.last(property_).next)\n          const value_ = _.drop(value, puncIndex + 1)\n          if (punctuation === '{') {\n            const block = this.parse_block()\n            value_.push(block)\n            next = block.next\n          }\n          const valueNode = this.createNode(\n            'value', value_, _.first(value_).start, _.last(value_).next)\n          const declarationValue = [propertyNode, value[puncIndex], valueNode]\n          if (punctuation === ';') {\n            const { start } = this.skip_punctuation(';')\n            declarationValue.push(start)\n            next = next.start\n          }\n          return this.createNode(\n            'declaration', declarationValue, start, next)\n        }\n      }\n      return false\n    }\n\n    while (!this.tokens.eof()) {\n      // AtRule\n      if (this.is_atkeyword()) {\n        return value.concat(this.parse_at_rule())\n      }\n      // Atom\n      value.push(this.parse_atom())\n      // Rule\n      if (this.is_punctuation('{')) {\n        if (value.length) {\n          return maybe_declaration('{') || this.parse_rule(value)\n        } else {\n          // TODO: throw error?\n          return value.concat(this.parse_block())\n        }\n      }\n      // Declaration\n      if (this.is_punctuation(';')) {\n        return maybe_declaration(';')\n      }\n    }\n    return value\n  }\n\n  /**\n   * Parse as many atoms as possible while the predicate is true\n   *\n   * @private\n   * @param {function} predicate\n   * @returns {Node[]}\n   */\n  parse_expression (predicate) {\n    let value = []\n    let declaration = []\n    while (true) {\n      if (this.tokens.eof() || !predicate()) break\n      // Declaration\n      if (this.is_punctuation(':') && declaration.length) {\n        value.push(this.parse_declaration(declaration))\n        // Remove the items that are now a declaration\n        value = _.xor(value, declaration)\n        declaration = []\n      }\n      // Atom\n      if (this.tokens.eof() || !predicate()) break\n      const atom = this.parse_atom()\n      value.push(atom)\n      // Collect items that might be parsed as a declaration\n      // $map: (\"red\": \"blue\", \"hello\": \"world\");\n      switch (atom.type) {\n        case 'space':\n        case 'punctuation':\n          break\n        default:\n          declaration.push(atom)\n      }\n    }\n    return value\n  }\n\n  /**\n   * Parse a single atom\n   *\n   * @private\n   * @returns {Node}\n   */\n  parse_atom () {\n    return this.maybe_function(() => {\n      // Parens\n      if (this.is_punctuation('(')) {\n        return this.parse_wrapped('parentheses', '(', ')')\n      }\n      // Interpolation\n      if (this.is_interpolation()) {\n        return this.parse_interolation()\n      }\n      // Attr\n      if (this.is_punctuation('[')) {\n        return this.parse_wrapped('attribute', '[', ']')\n      }\n      // Class\n      if (this.is_punctuation('.')) {\n        return this.parse_selector('class', '.')\n      }\n      // Id\n      if (this.is_punctuation('#')) {\n        return this.parse_selector('id', '#')\n      }\n      // Pseudo Element\n      if (this.is_punctuation('::')) {\n        return this.parse_selector('pseudo_element', ':')\n      }\n      // Pseudo Class\n      if (this.is_punctuation(':')) {\n        const next = this.tokens.peek(1)\n        if (\n          (next.type === 'identifier') ||\n          (next.type === 'punctuation' && next.value === '#')\n        ) {\n          return this.parse_selector('pseudo_class', ':')\n        }\n      }\n      // Token\n      return this.tokens.next()\n    })\n  }\n\n  /**\n   * Parse a declaration\n   *\n   * @private\n   * @param {Node[]} property\n   * @returns {Node}\n   */\n  parse_declaration (property) {\n    const { start: firstSeparator } = this.skip_punctuation(':')\n    // Expression\n    let secondSeparator\n    const value = this.parse_expression(() => {\n      if (this.is_punctuation(';')) {\n        secondSeparator = this.tokens.next()\n        return false\n      }\n      if (this.is_punctuation(',')) {\n        secondSeparator = this.tokens.next()\n        return false\n      }\n      if (this.is_punctuation(')')) return false\n      return true\n    })\n    const propertyNode = this.createNode(\n      'property', property, _.first(property).start, _.last(property).next)\n    const valueNode = this.createNode(\n      'value', value, _.first(value).start, _.last(value).next)\n    const declarationValue = [propertyNode, firstSeparator, valueNode]\n    if (secondSeparator) declarationValue.push(secondSeparator)\n    return this.createNode(\n      'declaration', declarationValue, _.first(property).start, _.last(value).next)\n  }\n\n  /**\n   * Parse an expression wrapped in the provided chracters\n   *\n   * @private\n   * @param {string} type\n   * @param {string} open\n   * @param {string} close\n   * @param {InputToken~Position} start\n   * @returns {Node}\n   */\n  parse_wrapped (type, open, close, _start) {\n    const { start } = this.skip_punctuation(open)\n    const value = this.parse_expression(() =>\n      !this.is_punctuation(close)\n    )\n    const { next } = this.skip_punctuation(close)\n    return this.createNode(type, value, (_start || start).start, next.next)\n  }\n\n  /**\n   * Parse Nodes wrapped in \"{}\"\n   *\n   * @private\n   * @returns {Node}\n   */\n  parse_block () {\n    const { start } = this.skip_punctuation('{')\n    const value = []\n    while (\n      (!this.tokens.eof()) &&\n      (!this.is_punctuation('}'))\n    ) {\n      const node = this.parse_node()\n      if (_.isArray(node)) {\n        value.push(...node)\n      } else {\n        value.push(node)\n      }\n    }\n    const { next } = this.skip_punctuation('}')\n    // Sass allows blocks to end with semicolons\n    if (this.is_punctuation(';')) {\n      this.skip_punctuation(';')\n    }\n    return this.createNode('block', value, start.start, next.next)\n  }\n\n  /**\n   * Parse comma separated expressions wrapped in \"()\"\n   *\n   * @private\n   * @param {string} [type] the type attrribute of the caller\n   * @returns {Node}\n   */\n  parse_arguments (type) {\n    const { start } = this.skip_punctuation('(')\n    let value = []\n    if (type === 'pseudo_class') {\n      while (!this.tokens.eof() && !this.is_punctuation(')')) {\n        value.push(this.parse_atom())\n      }\n    } else {\n      while (!this.tokens.eof() && !this.is_punctuation(')')) {\n        value = value.concat(this.parse_expression(() => {\n          if (this.is_punctuation(',')) return false\n          if (this.is_punctuation(')')) return false\n          return true\n        }))\n        if (this.is_punctuation(',')) {\n          value.push(this.tokens.next())\n        }\n      }\n    }\n    const { next } = this.skip_punctuation(')')\n    return this.createNode(\n      'arguments', value, start.start, next.next)\n  }\n\n  /**\n   * Optionally wrap a node in a \"function\"\n   *\n   * @private\n   * @param {function} node - returns a node to optionally be wrapped\n   * @returns {Node}\n   */\n  maybe_function (node) {\n    node = node()\n    const types = ['identifier', 'function', 'interpolation', 'pseudo_class']\n    return this.is_punctuation('(') && _.includes(types, node.type)\n      ? this.parse_function(node) : node\n  }\n\n  /**\n   * Parse a function node\n   *\n   * @private\n   * @params {Node} node - the node to wrap (usually an identifier)\n   * @returns {Node}\n   */\n  parse_function (node) {\n    const args = this.parse_arguments(node.type)\n    return this.createNode(\n      'function', [node, args], node.start, args.next)\n  }\n\n  /**\n   * Parse interpolation\n   *\n   * @private\n   * @returns {Node}\n   */\n  parse_interolation () {\n    const { start } = this.skip_punctuation('#')\n    return this.parse_wrapped('interpolation', '{', '}', start)\n  }\n\n  /**\n   * Parse an atrule\n   *\n   * @private\n   * @returns {Node}\n   */\n  parse_at_rule () {\n    const { start } = this.skip_atkeyword()\n    const value = [start]\n    // Space\n    if (this.is_space()) value.push(this.tokens.next())\n    // Identifier (prevent args being converted to a \"function\")\n    if (this.is_identifier()) value.push(this.tokens.next())\n    // Go\n    while (!this.tokens.eof()) {\n      if (this.is_punctuation('(') && /mixin|include|function/.test(start.value)) {\n        value.push(this.parse_arguments())\n      }\n      if (this.is_punctuation('{')) {\n        value.push(this.parse_block())\n        break\n      }\n      if (this.is_punctuation(';')) {\n        value.push(this.tokens.next())\n        break\n      } else {\n        value.push(this.parse_atom())\n      }\n    }\n    return this.createNode('atrule', value, start.start, _.last(value).next)\n  }\n\n  /**\n   * Parse a rule\n   *\n   * @private\n   * @param {Node[]} selectors\n   * @returns {Node}\n   */\n  parse_rule (selectors) {\n    const selector = this.createNode(\n      'selector', selectors, _.first(selectors).start, _.last(selectors).next)\n    const block = this.parse_block()\n    return this.createNode(\n      'rule', [selector, block], selector.start, block.next)\n  }\n\n  /**\n   * Parse selector starting with the provided punctuation\n   *\n   * @private\n   * @param {string} type\n   * @param {string} punctuation\n   * @returns {Node}\n   */\n  parse_selector (type, punctuation) {\n    const { start } = this.skip_punctuation(punctuation)\n    // Pseudo Element\n    if (this.is_punctuation(':')) {\n      this.skip_punctuation(':')\n    }\n    const value = []\n    let next = this.is_interpolation()\n      ? this.parse_interolation() : this.tokens.next()\n    // Selectors can be a combination of identifiers and interpolation\n    while (next.type === 'identifier' || next.type === 'interpolation' || next.type === 'operator') {\n      value.push(next)\n      next = this.is_interpolation()\n        ? this.parse_interolation() : this.tokens.peek()\n      if (!next) break\n      if (next.type === 'identifier') this.tokens.next()\n      // This is usually a dash following interpolation because identifiers\n      // can't start with a dash\n      if (next.type === 'operator') this.tokens.next()\n    }\n    if (!value.length) {\n      this.tokens.err(`Selector (\"${type}\") expected \"identifier\" or \"interpolation\"`)\n    }\n    return this.createNode(type, value, start.start, _.last(value).next)\n  }\n}\n\n/**\n * @function parseTokenStream\n * @private\n * @param {TokenStreamProxt} tokenStream\n * @returns {TokenStreamProxy}\n */\nmodule.exports = (tokenStream) => {\n  invariant(\n    _.isPlainObject(tokenStream) && _.has(tokenStream, 'next'),\n    'Parser requires a TokenStream'\n  )\n  const parser = new Parser(tokenStream)\n  return parser.parse_stylesheet()\n}\n\n\n//# sourceURL=webpack://blazor-app/../../node_modules/scss-parser/lib/parse.js?");

/***/ }),

/***/ "../../node_modules/scss-parser/lib/stringify.js":
/*!*******************************************************!*\
  !*** ../../node_modules/scss-parser/lib/stringify.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\nCopyright (c) 2016, salesforce.com, inc. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of salesforce.com, inc. nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* eslint-disable camelcase */\n\nconst _ = __webpack_require__(/*! lodash */ \"../../node_modules/lodash/lodash.js\")\n\nconst type = {\n  arguments: (n) =>\n    '(' + walkValue(n.value) + ')',\n  atkeyword: (n) =>\n    '@' + n.value,\n  attribute: (n) =>\n    '[' + walkValue(n.value) + ']',\n  block: (n) =>\n    '{' + walkValue(n.value) + '}',\n  class: (n) =>\n    '.' + walkValue(n.value),\n  color_hex: (n) =>\n    '#' + n.value,\n  id: (n) =>\n    '#' + walkValue(n.value),\n  interpolation: (n) =>\n    '#{' + walkValue(n.value) + '}',\n  comment_multiline: (n) =>\n    '/*' + n.value + '*/',\n  comment_singleline: (n) =>\n    '//' + n.value,\n  parentheses: (n) =>\n    '(' + walkValue(n.value) + ')',\n  pseudo_class: (n) =>\n    ':' + walkValue(n.value),\n  psuedo_element: (n) =>\n    '::' + walkValue(n.value),\n  string_double: (n) =>\n   `\"${n.value}\"`,\n  string_single: (n) =>\n   `'${n.value}'`,\n  variable: (n) =>\n    '$' + n.value\n}\n\nconst walkNode = (node) => {\n  if (type[node.type]) return type[node.type](node)\n  if (_.isString(node.value)) return node.value\n  if (_.isArray(node.value)) return walkValue(node.value)\n  return ''\n}\n\nconst walkValue = (value) => {\n  if (!_.isArray(value)) return ''\n  return value.reduce((s, node) => {\n    return s + walkNode(node)\n  }, '')\n}\n\nmodule.exports = (node) => walkNode(node)\n\n\n//# sourceURL=webpack://blazor-app/../../node_modules/scss-parser/lib/stringify.js?");

/***/ }),

/***/ "../../node_modules/scss-parser/lib/token-stream.js":
/*!**********************************************************!*\
  !*** ../../node_modules/scss-parser/lib/token-stream.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\nCopyright (c) 2016, salesforce.com, inc. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nNeither the name of salesforce.com, inc. nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* eslint-disable camelcase */\n\nconst _ = __webpack_require__(/*! lodash */ \"../../node_modules/lodash/lodash.js\")\nconst invariant = __webpack_require__(/*! invariant */ \"../../node_modules/invariant/invariant.js\")\n\nconst HEX_PATTERN = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/\n\n/**\n * Takes a predicate function and returns its inverse\n *\n * @private\n * @param {function} p\n * @returns {function}\n */\nconst not = (p) => (c) => !p(c)\n\n/**\n * Return a function that matches the provided character\n *\n * @private\n * @param {function} c\n * @returns {function}\n */\nconst is_char = (c) => (cc) => c === cc\n\n/**\n * Return true if the character matches whitespace\n *\n * @private\n * @param {string} c\n * @returns {boolean}\n */\nconst is_whitespace = (c) => '\\t\\r\\n '.indexOf(c) >= 0\n\n/**\n * Return true if the character matches a newline\n *\n * @private\n * @param {string} c\n * @returns {boolean}\n */\nconst is_newline = (c) => c === '\\n'\n\n/**\n * Return true if the character matches an operator\n *\n * @private\n * @param {string} c\n * @returns {boolean}\n */\nconst is_operator = (c) => '+-*/%=&|!~><^'.indexOf(c) >= 0\n\n/**\n * Return true if the provided operated can be repeated\n *\n * @private\n * @param {string} c\n * @returns {boolean}\n */\nconst is_operator_repeatable = (c) => '&|='.indexOf(c) >= 0\n\n/**\n * Return true if the character matches a punctuation\n *\n * @private\n * @param {string} c\n * @returns {boolean}\n */\nconst is_punctuation = (c) => ',;(){}[]:#.'.indexOf(c) >= 0\n\n/**\n * Return true if the character matches a digit\n *\n * @private\n * @param {string} c\n * @returns {boolean}\n */\nconst is_digit = (c) => /[0-9]/i.test(c)\n\n/**\n * Return true if input matches a comment\n *\n * @private\n * @param {InputStreamProxt} input\n * @returns {boolean}\n */\nconst is_comment_start = (input) =>\n  (input.peek() === '/' && (input.peek(1) === '/' || input.peek(1) === '*'))\n\n/**\n * Return true if the character matches the start of an identifier\n *\n * @private\n * @param {string} c\n * @returns {boolean}\n */\nconst is_ident_start = (c) => /[a-z_]/i.test(c)\n\n/**\n * Return true if the character matches an identifier\n *\n * @private\n * @param {string} c\n * @returns {boolean}\n */\nconst is_ident = (c) => /[a-z0-9_-]/i.test(c)\n\n/**\n * Return true if input matches the start of a number\n *\n * @private\n * @param {InputStreamProxt} input\n * @returns {boolean}\n */\nconst is_number_start = (input) =>\n  is_digit(input.peek()) || (input.peek() === '.' && is_digit(input.peek(1)))\n\n/**\n * Return the length of a possible hex color\n *\n * @private\n * @param {InputStreamProxt} input\n * @returns {number|boolean}\n */\nconst is_hex = (input) => {\n  let hex = input.peek()\n  if (hex === '#') {\n    let _3 = false\n    let _6 = false\n    while (hex.length < 7) {\n      const c = input.peek(hex.length)\n      if (_.isEmpty(c)) break\n      hex += c\n      if (hex.length === 4) _3 = HEX_PATTERN.test(hex)\n      if (hex.length === 7) _6 = HEX_PATTERN.test(hex)\n    }\n    return _6 ? 6 : _3 ? 3 : false\n  }\n  return false\n}\n\n/*\n * @typedef {object} Token\n * @property {string} type\n * @property {string|array} value\n * @property {InputStream~Position} start\n * @property {InputStream~Position} next\n */\n\n/**\n * Yield tokens from an {@link InputStream}\n *\n * @protected\n * @class\n */\nclass TokenStream {\n  /**\n   * Create a new InputStream\n   *\n   * @param {InputStreamProxy} input\n   */\n  constructor (input) {\n    invariant(\n      _.isPlainObject(input) && _.has(input, 'next'),\n      'TokenStream requires an InputStream'\n    )\n    this.input = input\n    this.tokens = []\n  }\n\n  /**\n   * Return a new @{link Token}\n   *\n   * @private\n   * @param {string} type\n   * @param {string|array} value\n   * @param {InputStream~Position} start\n   * @returns {Token}\n   */\n  createToken (type, value, start) {\n    return Object.freeze({\n      type,\n      value,\n      start,\n      next: this.input.position()\n    })\n  }\n\n  /**\n   * Return the current token with an optional offset\n   *\n   * @public\n   * @param {number} offset\n   * @returns {Token}\n   */\n  peek (offset) {\n    if (!this.tokens.length) {\n      const token = this.read_next()\n      if (token) this.tokens.push(token)\n    }\n    if (!offset) return this.tokens[0]\n    if (offset < this.tokens.length) return this.tokens[offset]\n    while (this.tokens.length <= offset) {\n      const token = this.read_next()\n      if (token) this.tokens.push(token)\n      else break\n    }\n    return this.tokens[offset]\n  }\n\n  /**\n   * Return the current token and advance the TokenStream\n   *\n   * @public\n   * @returns {Token}\n   */\n  next () {\n    const token = this.tokens.shift()\n    return token || this.read_next()\n  }\n\n  /**\n   * Return true if the stream has reached the end\n   *\n   * @public\n   * @returns {boolean}\n   */\n  eof () {\n    return typeof this.peek() === 'undefined'\n  }\n\n  /**\n   * Throw an error at the current line/column\n   *\n   * @public\n   * @param {string} message\n   * @throws Error\n   */\n  err () {\n    return this.input.err(...arguments)\n  }\n\n  /**\n   * Parse the next character(s) as a Token\n   *\n   * @private\n   * @returns {Token}\n   */\n  read_next () {\n    if (this.input.eof()) return null\n    const c = this.input.peek()\n    // Whitespace\n    if (is_whitespace(c)) {\n      return this.read_whitespace()\n    }\n    // Comments\n    if (is_comment_start(this.input)) {\n      return this.read_comment()\n    }\n    // Number\n    if (is_number_start(this.input)) {\n      return this.read_number()\n    }\n    // Hex\n    const hex_length = is_hex(this.input)\n    if (hex_length) {\n      return this.read_hex(hex_length)\n    }\n    // Punctutation\n    if (is_punctuation(c)) {\n      return this.read_punctuation()\n    }\n    // Identifier\n    if (is_ident_start(c)) {\n      return this.read_ident()\n    }\n    // Operator\n    if (is_operator(c)) {\n      return this.read_operator()\n    }\n    // String\n    if (c === '\"' || c === '\\'') {\n      return this.read_string(c)\n    }\n    // @ keyword\n    if (c === '@') {\n      return this.read_atkeyword()\n    }\n    // Variable\n    if (c === '$') {\n      return this.read_variable()\n    }\n    this.err(`Can't handle character: \"${c}\"`)\n  }\n\n  /**\n   * Advance the input while the prediciate is true\n   *\n   * @private\n   * @param {function} predicate\n   * @returns {string}\n   */\n  read_while (predicate) {\n    let s = ''\n    while (!this.input.eof() && predicate(this.input.peek())) {\n      s += this.input.next()\n    }\n    return s\n  }\n\n  /**\n   * Advance the input (consuming escaped characters) until the end character\n   * is reached\n   *\n   * @private\n   * @param {string} end\n   * @returns {string}\n   */\n  read_escaped (end) {\n    let escaped = false\n    let str = ''\n    this.input.next()\n    while (!this.input.eof()) {\n      const c = this.input.next()\n      if (escaped) {\n        str += c\n        escaped = false\n      } else if (c === '\\\\') {\n        str += c\n        escaped = true\n      } else if (c === end) {\n        break\n      } else {\n        str += c\n      }\n    }\n    return str\n  }\n\n  /**\n   * Advance the input while whitespace characters are matched\n   *\n   * @private\n   * @returns {Token}\n   */\n  read_whitespace () {\n    const start = this.input.position()\n    const value = this.read_while(is_whitespace)\n    return this.createToken('space', value, start)\n  }\n\n  /**\n   * Advance the input while comment characters are matched\n   *\n   * @private\n   * @returns {Token}\n   */\n  read_comment () {\n    const start = this.input.position()\n    this.input.next()\n    switch (this.input.next()) {\n      case '/':\n        return this.read_comment_single(start)\n      case '*':\n        return this.read_comment_multi(start)\n    }\n  }\n\n  /**\n   * Advance the input while singleline comment characters are matched\n   *\n   * @private\n   * @params {InputStream~Position} start\n   * @returns {Token}\n   */\n  read_comment_single (start) {\n    const value = this.read_while(not(is_newline))\n    return this.createToken('comment_singleline', value, start)\n  }\n\n  /**\n   * Advance the input while multiline comment characters are matched\n   *\n   * @private\n   * @params {InputStream~Position} start\n   * @returns {Token}\n   */\n  read_comment_multi (start) {\n    let prev = ''\n    let value = ''\n    while (!this.input.eof()) {\n      const next = this.input.next()\n      if (next === '/' && prev === '*') break\n      value += prev\n      prev = next\n    }\n    return this.createToken('comment_multiline', value, start)\n  }\n\n  /**\n   * Advance the input while punctuation characters are matched\n   *\n   * @private\n   * @returns {Token}\n   */\n  read_punctuation () {\n    const start = this.input.position()\n    const value = this.input.next()\n    return this.createToken('punctuation', value, start)\n  }\n\n  /**\n   * Advance the input while operators characters are matched\n   *\n   * @private\n   * @returns {Token}\n   */\n  read_operator () {\n    const start = this.input.position()\n    const c = this.input.peek()\n    const value = is_operator_repeatable(c)\n      ? this.read_while(is_char(c)) : this.input.next()\n    return this.createToken('operator', value, start)\n  }\n\n  /**\n   * Advance the input while identifier characters are matched\n   *\n   * @private\n   * @returns {Token}\n   */\n  read_ident () {\n    const start = this.input.position()\n    const value = this.read_while(is_ident)\n    return this.createToken('identifier', value, start)\n  }\n\n  /**\n   * Advance the input while string characters are matched\n   *\n   * @private\n   * @param {string} c - \" or '\n   * @returns {Token}\n   */\n  read_string (c) {\n    const start = this.input.position()\n    const value = this.read_escaped(c)\n    let type = 'string'\n    if (c === '\"') type = 'string_double'\n    if (c === '\\'') type = 'string_single'\n    return this.createToken(type, value, start)\n  }\n\n  /**\n   * Advance the input while number characters are matched\n   *\n   * @private\n   * @returns {Token}\n   */\n  read_number () {\n    const start = this.input.position()\n    let hasPoint = false\n    const value = this.read_while((c) => {\n      if (c === '.') {\n        if (hasPoint) return false\n        hasPoint = true\n        return true\n      }\n      return is_digit(c)\n    })\n    return this.createToken('number', value, start)\n  }\n\n  /**\n   * Advance the input while hex characters are matched\n   *\n   * @private\n   * @returns {Token}\n   */\n  read_hex (length) {\n    const start = this.input.position()\n    this.input.next()\n    let value = ''\n    for (let i = 0; i < length; i++) {\n      value += this.input.next()\n    }\n    return this.createToken('color_hex', value, start)\n  }\n\n  /**\n   * Advance the input while atkeyword characters are matched\n   *\n   * @private\n   * @returns {Token}\n   */\n  read_atkeyword () {\n    const start = this.input.position()\n    this.input.next()\n    const value = this.read_while(is_ident)\n    return this.createToken('atkeyword', value, start)\n  }\n\n  /**\n   * Advance the input while variable characters are matched\n   *\n   * @private\n   * @returns {Token}\n   */\n  read_variable () {\n    const start = this.input.position()\n    this.input.next()\n    const value = this.read_while(is_ident)\n    return this.createToken('variable', value, start)\n  }\n}\n\n/**\n * @function createTokenStream\n * @private\n * @param {InputStreamProxy} input\n * @returns {TokenStreamProxy}\n */\nmodule.exports = (input) => {\n  const t = new TokenStream(input)\n  /**\n   * @namespace\n   * @borrows TokenStream#peek as #peek\n   * @borrows TokenStream#next as #next\n   * @borrows TokenStream#eof as #eof\n   * @borrows TokenStream#err as #err\n   */\n  const TokenStreamProxy = {\n    peek () {\n      return t.peek(...arguments)\n    },\n    next () {\n      return t.next()\n    },\n    eof () {\n      return t.eof()\n    },\n    err () {\n      return t.err(...arguments)\n    },\n    /**\n     * Yield all tokens from the stream\n     *\n     * @instance\n     * @returns {Token[]}\n     */\n    all () {\n      const tokens = []\n      while (!t.eof()) tokens.push(t.next())\n      return tokens\n    }\n  }\n  return TokenStreamProxy\n}\n\n\n//# sourceURL=webpack://blazor-app/../../node_modules/scss-parser/lib/token-stream.js?");

/***/ }),

/***/ "../../node_modules/tailwindcss/lib/util/createPlugin.js":
/*!***************************************************************!*\
  !*** ../../node_modules/tailwindcss/lib/util/createPlugin.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.default = void 0;\n\nfunction createPlugin(plugin, config) {\n  return {\n    handler: plugin,\n    config\n  };\n}\n\ncreatePlugin.withOptions = function (pluginFunction, configFunction = () => ({})) {\n  const optionsFunction = function (options) {\n    return {\n      __options: options,\n      handler: pluginFunction(options),\n      config: configFunction(options)\n    };\n  };\n\n  optionsFunction.__isOptionsFunction = true; // Expose plugin dependencies so that `object-hash` returns a different\n  // value if anything here changes, to ensure a rebuild is triggered.\n\n  optionsFunction.__pluginFunction = pluginFunction;\n  optionsFunction.__configFunction = configFunction;\n  return optionsFunction;\n};\n\nvar _default = createPlugin;\nexports.default = _default;\n\n//# sourceURL=webpack://blazor-app/../../node_modules/tailwindcss/lib/util/createPlugin.js?");

/***/ }),

/***/ "../../node_modules/tailwindcss/plugin.js":
/*!************************************************!*\
  !*** ../../node_modules/tailwindcss/plugin.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const createPlugin = __webpack_require__(/*! ./lib/util/createPlugin */ \"../../node_modules/tailwindcss/lib/util/createPlugin.js\")\n\nmodule.exports = (createPlugin.__esModule ? createPlugin : { default: createPlugin }).default\n\n\n//# sourceURL=webpack://blazor-app/../../node_modules/tailwindcss/plugin.js?");

/***/ })

};
;