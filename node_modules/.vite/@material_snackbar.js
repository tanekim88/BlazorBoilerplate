import {
  closest
} from "./chunk-WYKVOA7L.js";
import {
  MDCComponent,
  MDCFoundation,
  __assign,
  __export,
  __extends,
  __name
} from "./chunk-M3SJFXWQ.js";

// node_modules/@material/snackbar/util.js
var util_exports = {};
__export(util_exports, {
  announce: () => announce
});

// node_modules/@material/snackbar/constants.js
var cssClasses = {
  CLOSING: "mdc-snackbar--closing",
  OPEN: "mdc-snackbar--open",
  OPENING: "mdc-snackbar--opening"
};
var strings = {
  ACTION_SELECTOR: ".mdc-snackbar__action",
  ARIA_LIVE_LABEL_TEXT_ATTR: "data-mdc-snackbar-label-text",
  CLOSED_EVENT: "MDCSnackbar:closed",
  CLOSING_EVENT: "MDCSnackbar:closing",
  DISMISS_SELECTOR: ".mdc-snackbar__dismiss",
  LABEL_SELECTOR: ".mdc-snackbar__label",
  OPENED_EVENT: "MDCSnackbar:opened",
  OPENING_EVENT: "MDCSnackbar:opening",
  REASON_ACTION: "action",
  REASON_DISMISS: "dismiss",
  SURFACE_SELECTOR: ".mdc-snackbar__surface"
};
var numbers = {
  DEFAULT_AUTO_DISMISS_TIMEOUT_MS: 5e3,
  INDETERMINATE: -1,
  MAX_AUTO_DISMISS_TIMEOUT_MS: 1e4,
  MIN_AUTO_DISMISS_TIMEOUT_MS: 4e3,
  SNACKBAR_ANIMATION_CLOSE_TIME_MS: 75,
  SNACKBAR_ANIMATION_OPEN_TIME_MS: 150,
  ARIA_LIVE_DELAY_MS: 1e3
};

// node_modules/@material/snackbar/util.js
var ARIA_LIVE_DELAY_MS = numbers.ARIA_LIVE_DELAY_MS;
var ARIA_LIVE_LABEL_TEXT_ATTR = strings.ARIA_LIVE_LABEL_TEXT_ATTR;
function announce(ariaEl, labelEl) {
  if (labelEl === void 0) {
    labelEl = ariaEl;
  }
  var priority = ariaEl.getAttribute("aria-live");
  var labelText = labelEl.textContent.trim();
  if (!labelText || !priority) {
    return;
  }
  ariaEl.setAttribute("aria-live", "off");
  labelEl.textContent = "";
  labelEl.innerHTML = '<span style="display: inline-block; width: 0; height: 1px;">&nbsp;</span>';
  labelEl.setAttribute(ARIA_LIVE_LABEL_TEXT_ATTR, labelText);
  setTimeout(function() {
    ariaEl.setAttribute("aria-live", priority);
    labelEl.removeAttribute(ARIA_LIVE_LABEL_TEXT_ATTR);
    labelEl.textContent = labelText;
  }, ARIA_LIVE_DELAY_MS);
}
__name(announce, "announce");

// node_modules/@material/snackbar/foundation.js
var OPENING = cssClasses.OPENING;
var OPEN = cssClasses.OPEN;
var CLOSING = cssClasses.CLOSING;
var REASON_ACTION = strings.REASON_ACTION;
var REASON_DISMISS = strings.REASON_DISMISS;
var MDCSnackbarFoundation = function(_super) {
  __extends(MDCSnackbarFoundation2, _super);
  function MDCSnackbarFoundation2(adapter) {
    var _this = _super.call(this, __assign(__assign({}, MDCSnackbarFoundation2.defaultAdapter), adapter)) || this;
    _this.opened = false;
    _this.animationFrame = 0;
    _this.animationTimer = 0;
    _this.autoDismissTimer = 0;
    _this.autoDismissTimeoutMs = numbers.DEFAULT_AUTO_DISMISS_TIMEOUT_MS;
    _this.closeOnEscape = true;
    return _this;
  }
  __name(MDCSnackbarFoundation2, "MDCSnackbarFoundation");
  Object.defineProperty(MDCSnackbarFoundation2, "cssClasses", {
    get: function() {
      return cssClasses;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCSnackbarFoundation2, "strings", {
    get: function() {
      return strings;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCSnackbarFoundation2, "numbers", {
    get: function() {
      return numbers;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCSnackbarFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClass: function() {
          return void 0;
        },
        announce: function() {
          return void 0;
        },
        notifyClosed: function() {
          return void 0;
        },
        notifyClosing: function() {
          return void 0;
        },
        notifyOpened: function() {
          return void 0;
        },
        notifyOpening: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCSnackbarFoundation2.prototype.destroy = function() {
    this.clearAutoDismissTimer();
    cancelAnimationFrame(this.animationFrame);
    this.animationFrame = 0;
    clearTimeout(this.animationTimer);
    this.animationTimer = 0;
    this.adapter.removeClass(OPENING);
    this.adapter.removeClass(OPEN);
    this.adapter.removeClass(CLOSING);
  };
  MDCSnackbarFoundation2.prototype.open = function() {
    var _this = this;
    this.clearAutoDismissTimer();
    this.opened = true;
    this.adapter.notifyOpening();
    this.adapter.removeClass(CLOSING);
    this.adapter.addClass(OPENING);
    this.adapter.announce();
    this.runNextAnimationFrame(function() {
      _this.adapter.addClass(OPEN);
      _this.animationTimer = setTimeout(function() {
        var timeoutMs = _this.getTimeoutMs();
        _this.handleAnimationTimerEnd();
        _this.adapter.notifyOpened();
        if (timeoutMs !== numbers.INDETERMINATE) {
          _this.autoDismissTimer = setTimeout(function() {
            _this.close(REASON_DISMISS);
          }, timeoutMs);
        }
      }, numbers.SNACKBAR_ANIMATION_OPEN_TIME_MS);
    });
  };
  MDCSnackbarFoundation2.prototype.close = function(reason) {
    var _this = this;
    if (reason === void 0) {
      reason = "";
    }
    if (!this.opened) {
      return;
    }
    cancelAnimationFrame(this.animationFrame);
    this.animationFrame = 0;
    this.clearAutoDismissTimer();
    this.opened = false;
    this.adapter.notifyClosing(reason);
    this.adapter.addClass(cssClasses.CLOSING);
    this.adapter.removeClass(cssClasses.OPEN);
    this.adapter.removeClass(cssClasses.OPENING);
    clearTimeout(this.animationTimer);
    this.animationTimer = setTimeout(function() {
      _this.handleAnimationTimerEnd();
      _this.adapter.notifyClosed(reason);
    }, numbers.SNACKBAR_ANIMATION_CLOSE_TIME_MS);
  };
  MDCSnackbarFoundation2.prototype.isOpen = function() {
    return this.opened;
  };
  MDCSnackbarFoundation2.prototype.getTimeoutMs = function() {
    return this.autoDismissTimeoutMs;
  };
  MDCSnackbarFoundation2.prototype.setTimeoutMs = function(timeoutMs) {
    var minValue = numbers.MIN_AUTO_DISMISS_TIMEOUT_MS;
    var maxValue = numbers.MAX_AUTO_DISMISS_TIMEOUT_MS;
    var indeterminateValue = numbers.INDETERMINATE;
    if (timeoutMs === numbers.INDETERMINATE || timeoutMs <= maxValue && timeoutMs >= minValue) {
      this.autoDismissTimeoutMs = timeoutMs;
    } else {
      throw new Error("\n        timeoutMs must be an integer in the range " + minValue + "\u2013" + maxValue + "\n        (or " + indeterminateValue + " to disable), but got '" + timeoutMs + "'");
    }
  };
  MDCSnackbarFoundation2.prototype.getCloseOnEscape = function() {
    return this.closeOnEscape;
  };
  MDCSnackbarFoundation2.prototype.setCloseOnEscape = function(closeOnEscape) {
    this.closeOnEscape = closeOnEscape;
  };
  MDCSnackbarFoundation2.prototype.handleKeyDown = function(evt) {
    var isEscapeKey = evt.key === "Escape" || evt.keyCode === 27;
    if (isEscapeKey && this.getCloseOnEscape()) {
      this.close(REASON_DISMISS);
    }
  };
  MDCSnackbarFoundation2.prototype.handleActionButtonClick = function(_evt) {
    this.close(REASON_ACTION);
  };
  MDCSnackbarFoundation2.prototype.handleActionIconClick = function(_evt) {
    this.close(REASON_DISMISS);
  };
  MDCSnackbarFoundation2.prototype.clearAutoDismissTimer = function() {
    clearTimeout(this.autoDismissTimer);
    this.autoDismissTimer = 0;
  };
  MDCSnackbarFoundation2.prototype.handleAnimationTimerEnd = function() {
    this.animationTimer = 0;
    this.adapter.removeClass(cssClasses.OPENING);
    this.adapter.removeClass(cssClasses.CLOSING);
  };
  MDCSnackbarFoundation2.prototype.runNextAnimationFrame = function(callback) {
    var _this = this;
    cancelAnimationFrame(this.animationFrame);
    this.animationFrame = requestAnimationFrame(function() {
      _this.animationFrame = 0;
      clearTimeout(_this.animationTimer);
      _this.animationTimer = setTimeout(callback, 0);
    });
  };
  return MDCSnackbarFoundation2;
}(MDCFoundation);

// node_modules/@material/snackbar/component.js
var SURFACE_SELECTOR = strings.SURFACE_SELECTOR;
var LABEL_SELECTOR = strings.LABEL_SELECTOR;
var ACTION_SELECTOR = strings.ACTION_SELECTOR;
var DISMISS_SELECTOR = strings.DISMISS_SELECTOR;
var OPENING_EVENT = strings.OPENING_EVENT;
var OPENED_EVENT = strings.OPENED_EVENT;
var CLOSING_EVENT = strings.CLOSING_EVENT;
var CLOSED_EVENT = strings.CLOSED_EVENT;
var MDCSnackbar = function(_super) {
  __extends(MDCSnackbar2, _super);
  function MDCSnackbar2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  __name(MDCSnackbar2, "MDCSnackbar");
  MDCSnackbar2.attachTo = function(root) {
    return new MDCSnackbar2(root);
  };
  MDCSnackbar2.prototype.initialize = function(announcerFactory) {
    if (announcerFactory === void 0) {
      announcerFactory = /* @__PURE__ */ __name(function() {
        return announce;
      }, "announcerFactory");
    }
    this.announce = announcerFactory();
  };
  MDCSnackbar2.prototype.initialSyncWithDOM = function() {
    var _this = this;
    this.surfaceEl = this.root.querySelector(SURFACE_SELECTOR);
    this.labelEl = this.root.querySelector(LABEL_SELECTOR);
    this.actionEl = this.root.querySelector(ACTION_SELECTOR);
    this.handleKeyDown = function(evt) {
      _this.foundation.handleKeyDown(evt);
    };
    this.handleSurfaceClick = function(evt) {
      var target = evt.target;
      if (_this.isActionButton(target)) {
        _this.foundation.handleActionButtonClick(evt);
      } else if (_this.isActionIcon(target)) {
        _this.foundation.handleActionIconClick(evt);
      }
    };
    this.registerKeyDownHandler(this.handleKeyDown);
    this.registerSurfaceClickHandler(this.handleSurfaceClick);
  };
  MDCSnackbar2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
    this.deregisterKeyDownHandler(this.handleKeyDown);
    this.deregisterSurfaceClickHandler(this.handleSurfaceClick);
  };
  MDCSnackbar2.prototype.open = function() {
    this.foundation.open();
  };
  MDCSnackbar2.prototype.close = function(reason) {
    if (reason === void 0) {
      reason = "";
    }
    this.foundation.close(reason);
  };
  MDCSnackbar2.prototype.getDefaultFoundation = function() {
    var _this = this;
    var adapter = {
      addClass: function(className) {
        _this.root.classList.add(className);
      },
      announce: function() {
        _this.announce(_this.labelEl);
      },
      notifyClosed: function(reason) {
        return _this.emit(CLOSED_EVENT, reason ? { reason } : {});
      },
      notifyClosing: function(reason) {
        return _this.emit(CLOSING_EVENT, reason ? { reason } : {});
      },
      notifyOpened: function() {
        return _this.emit(OPENED_EVENT, {});
      },
      notifyOpening: function() {
        return _this.emit(OPENING_EVENT, {});
      },
      removeClass: function(className) {
        return _this.root.classList.remove(className);
      }
    };
    return new MDCSnackbarFoundation(adapter);
  };
  Object.defineProperty(MDCSnackbar2.prototype, "timeoutMs", {
    get: function() {
      return this.foundation.getTimeoutMs();
    },
    set: function(timeoutMs) {
      this.foundation.setTimeoutMs(timeoutMs);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCSnackbar2.prototype, "closeOnEscape", {
    get: function() {
      return this.foundation.getCloseOnEscape();
    },
    set: function(closeOnEscape) {
      this.foundation.setCloseOnEscape(closeOnEscape);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCSnackbar2.prototype, "isOpen", {
    get: function() {
      return this.foundation.isOpen();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCSnackbar2.prototype, "labelText", {
    get: function() {
      return this.labelEl.textContent;
    },
    set: function(labelText) {
      this.labelEl.textContent = labelText;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCSnackbar2.prototype, "actionButtonText", {
    get: function() {
      return this.actionEl.textContent;
    },
    set: function(actionButtonText) {
      this.actionEl.textContent = actionButtonText;
    },
    enumerable: false,
    configurable: true
  });
  MDCSnackbar2.prototype.registerKeyDownHandler = function(handler) {
    this.listen("keydown", handler);
  };
  MDCSnackbar2.prototype.deregisterKeyDownHandler = function(handler) {
    this.unlisten("keydown", handler);
  };
  MDCSnackbar2.prototype.registerSurfaceClickHandler = function(handler) {
    this.surfaceEl.addEventListener("click", handler);
  };
  MDCSnackbar2.prototype.deregisterSurfaceClickHandler = function(handler) {
    this.surfaceEl.removeEventListener("click", handler);
  };
  MDCSnackbar2.prototype.isActionButton = function(target) {
    return Boolean(closest(target, ACTION_SELECTOR));
  };
  MDCSnackbar2.prototype.isActionIcon = function(target) {
    return Boolean(closest(target, DISMISS_SELECTOR));
  };
  return MDCSnackbar2;
}(MDCComponent);
export {
  MDCSnackbar,
  MDCSnackbarFoundation,
  cssClasses,
  numbers,
  strings,
  util_exports as util
};
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
//# sourceMappingURL=@material_snackbar.js.map
