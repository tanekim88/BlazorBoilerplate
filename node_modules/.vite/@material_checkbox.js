import {
  getCorrectEventName
} from "./chunk-R23S4P3V.js";
import {
  MDCRipple,
  MDCRippleFoundation,
  applyPassive
} from "./chunk-ISQV23BK.js";
import {
  matches
} from "./chunk-WYKVOA7L.js";
import {
  MDCComponent,
  MDCFoundation,
  __assign,
  __extends,
  __name,
  __values
} from "./chunk-M3SJFXWQ.js";

// node_modules/@material/checkbox/constants.js
var cssClasses = {
  ANIM_CHECKED_INDETERMINATE: "mdc-checkbox--anim-checked-indeterminate",
  ANIM_CHECKED_UNCHECKED: "mdc-checkbox--anim-checked-unchecked",
  ANIM_INDETERMINATE_CHECKED: "mdc-checkbox--anim-indeterminate-checked",
  ANIM_INDETERMINATE_UNCHECKED: "mdc-checkbox--anim-indeterminate-unchecked",
  ANIM_UNCHECKED_CHECKED: "mdc-checkbox--anim-unchecked-checked",
  ANIM_UNCHECKED_INDETERMINATE: "mdc-checkbox--anim-unchecked-indeterminate",
  BACKGROUND: "mdc-checkbox__background",
  CHECKED: "mdc-checkbox--checked",
  CHECKMARK: "mdc-checkbox__checkmark",
  CHECKMARK_PATH: "mdc-checkbox__checkmark-path",
  DISABLED: "mdc-checkbox--disabled",
  INDETERMINATE: "mdc-checkbox--indeterminate",
  MIXEDMARK: "mdc-checkbox__mixedmark",
  NATIVE_CONTROL: "mdc-checkbox__native-control",
  ROOT: "mdc-checkbox",
  SELECTED: "mdc-checkbox--selected",
  UPGRADED: "mdc-checkbox--upgraded"
};
var strings = {
  ARIA_CHECKED_ATTR: "aria-checked",
  ARIA_CHECKED_INDETERMINATE_VALUE: "mixed",
  DATA_INDETERMINATE_ATTR: "data-indeterminate",
  NATIVE_CONTROL_SELECTOR: ".mdc-checkbox__native-control",
  TRANSITION_STATE_CHECKED: "checked",
  TRANSITION_STATE_INDETERMINATE: "indeterminate",
  TRANSITION_STATE_INIT: "init",
  TRANSITION_STATE_UNCHECKED: "unchecked"
};
var numbers = {
  ANIM_END_LATCH_MS: 250
};

// node_modules/@material/checkbox/foundation.js
var MDCCheckboxFoundation = function(_super) {
  __extends(MDCCheckboxFoundation2, _super);
  function MDCCheckboxFoundation2(adapter) {
    var _this = _super.call(this, __assign(__assign({}, MDCCheckboxFoundation2.defaultAdapter), adapter)) || this;
    _this.currentCheckState = strings.TRANSITION_STATE_INIT;
    _this.currentAnimationClass = "";
    _this.animEndLatchTimer = 0;
    _this.enableAnimationEndHandler = false;
    return _this;
  }
  __name(MDCCheckboxFoundation2, "MDCCheckboxFoundation");
  Object.defineProperty(MDCCheckboxFoundation2, "cssClasses", {
    get: function() {
      return cssClasses;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCCheckboxFoundation2, "strings", {
    get: function() {
      return strings;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCCheckboxFoundation2, "numbers", {
    get: function() {
      return numbers;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCCheckboxFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClass: function() {
          return void 0;
        },
        forceLayout: function() {
          return void 0;
        },
        hasNativeControl: function() {
          return false;
        },
        isAttachedToDOM: function() {
          return false;
        },
        isChecked: function() {
          return false;
        },
        isIndeterminate: function() {
          return false;
        },
        removeClass: function() {
          return void 0;
        },
        removeNativeControlAttr: function() {
          return void 0;
        },
        setNativeControlAttr: function() {
          return void 0;
        },
        setNativeControlDisabled: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCCheckboxFoundation2.prototype.init = function() {
    this.currentCheckState = this.determineCheckState();
    this.updateAriaChecked();
    this.adapter.addClass(cssClasses.UPGRADED);
  };
  MDCCheckboxFoundation2.prototype.destroy = function() {
    clearTimeout(this.animEndLatchTimer);
  };
  MDCCheckboxFoundation2.prototype.setDisabled = function(disabled) {
    this.adapter.setNativeControlDisabled(disabled);
    if (disabled) {
      this.adapter.addClass(cssClasses.DISABLED);
    } else {
      this.adapter.removeClass(cssClasses.DISABLED);
    }
  };
  MDCCheckboxFoundation2.prototype.handleAnimationEnd = function() {
    var _this = this;
    if (!this.enableAnimationEndHandler) {
      return;
    }
    clearTimeout(this.animEndLatchTimer);
    this.animEndLatchTimer = setTimeout(function() {
      _this.adapter.removeClass(_this.currentAnimationClass);
      _this.enableAnimationEndHandler = false;
    }, numbers.ANIM_END_LATCH_MS);
  };
  MDCCheckboxFoundation2.prototype.handleChange = function() {
    this.transitionCheckState();
  };
  MDCCheckboxFoundation2.prototype.transitionCheckState = function() {
    if (!this.adapter.hasNativeControl()) {
      return;
    }
    var oldState = this.currentCheckState;
    var newState = this.determineCheckState();
    if (oldState === newState) {
      return;
    }
    this.updateAriaChecked();
    var TRANSITION_STATE_UNCHECKED = strings.TRANSITION_STATE_UNCHECKED;
    var SELECTED = cssClasses.SELECTED;
    if (newState === TRANSITION_STATE_UNCHECKED) {
      this.adapter.removeClass(SELECTED);
    } else {
      this.adapter.addClass(SELECTED);
    }
    if (this.currentAnimationClass.length > 0) {
      clearTimeout(this.animEndLatchTimer);
      this.adapter.forceLayout();
      this.adapter.removeClass(this.currentAnimationClass);
    }
    this.currentAnimationClass = this.getTransitionAnimationClass(oldState, newState);
    this.currentCheckState = newState;
    if (this.adapter.isAttachedToDOM() && this.currentAnimationClass.length > 0) {
      this.adapter.addClass(this.currentAnimationClass);
      this.enableAnimationEndHandler = true;
    }
  };
  MDCCheckboxFoundation2.prototype.determineCheckState = function() {
    var TRANSITION_STATE_INDETERMINATE = strings.TRANSITION_STATE_INDETERMINATE, TRANSITION_STATE_CHECKED = strings.TRANSITION_STATE_CHECKED, TRANSITION_STATE_UNCHECKED = strings.TRANSITION_STATE_UNCHECKED;
    if (this.adapter.isIndeterminate()) {
      return TRANSITION_STATE_INDETERMINATE;
    }
    return this.adapter.isChecked() ? TRANSITION_STATE_CHECKED : TRANSITION_STATE_UNCHECKED;
  };
  MDCCheckboxFoundation2.prototype.getTransitionAnimationClass = function(oldState, newState) {
    var TRANSITION_STATE_INIT = strings.TRANSITION_STATE_INIT, TRANSITION_STATE_CHECKED = strings.TRANSITION_STATE_CHECKED, TRANSITION_STATE_UNCHECKED = strings.TRANSITION_STATE_UNCHECKED;
    var _a = MDCCheckboxFoundation2.cssClasses, ANIM_UNCHECKED_CHECKED = _a.ANIM_UNCHECKED_CHECKED, ANIM_UNCHECKED_INDETERMINATE = _a.ANIM_UNCHECKED_INDETERMINATE, ANIM_CHECKED_UNCHECKED = _a.ANIM_CHECKED_UNCHECKED, ANIM_CHECKED_INDETERMINATE = _a.ANIM_CHECKED_INDETERMINATE, ANIM_INDETERMINATE_CHECKED = _a.ANIM_INDETERMINATE_CHECKED, ANIM_INDETERMINATE_UNCHECKED = _a.ANIM_INDETERMINATE_UNCHECKED;
    switch (oldState) {
      case TRANSITION_STATE_INIT:
        if (newState === TRANSITION_STATE_UNCHECKED) {
          return "";
        }
        return newState === TRANSITION_STATE_CHECKED ? ANIM_INDETERMINATE_CHECKED : ANIM_INDETERMINATE_UNCHECKED;
      case TRANSITION_STATE_UNCHECKED:
        return newState === TRANSITION_STATE_CHECKED ? ANIM_UNCHECKED_CHECKED : ANIM_UNCHECKED_INDETERMINATE;
      case TRANSITION_STATE_CHECKED:
        return newState === TRANSITION_STATE_UNCHECKED ? ANIM_CHECKED_UNCHECKED : ANIM_CHECKED_INDETERMINATE;
      default:
        return newState === TRANSITION_STATE_CHECKED ? ANIM_INDETERMINATE_CHECKED : ANIM_INDETERMINATE_UNCHECKED;
    }
  };
  MDCCheckboxFoundation2.prototype.updateAriaChecked = function() {
    if (this.adapter.isIndeterminate()) {
      this.adapter.setNativeControlAttr(strings.ARIA_CHECKED_ATTR, strings.ARIA_CHECKED_INDETERMINATE_VALUE);
    } else {
      this.adapter.removeNativeControlAttr(strings.ARIA_CHECKED_ATTR);
    }
  };
  return MDCCheckboxFoundation2;
}(MDCFoundation);

// node_modules/@material/checkbox/component.js
var CB_PROTO_PROPS = ["checked", "indeterminate"];
var MDCCheckbox = function(_super) {
  __extends(MDCCheckbox2, _super);
  function MDCCheckbox2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.rippleSurface = _this.createRipple();
    return _this;
  }
  __name(MDCCheckbox2, "MDCCheckbox");
  MDCCheckbox2.attachTo = function(root) {
    return new MDCCheckbox2(root);
  };
  Object.defineProperty(MDCCheckbox2.prototype, "ripple", {
    get: function() {
      return this.rippleSurface;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCCheckbox2.prototype, "checked", {
    get: function() {
      return this.getNativeControl().checked;
    },
    set: function(checked) {
      this.getNativeControl().checked = checked;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCCheckbox2.prototype, "indeterminate", {
    get: function() {
      return this.getNativeControl().indeterminate;
    },
    set: function(indeterminate) {
      this.getNativeControl().indeterminate = indeterminate;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCCheckbox2.prototype, "disabled", {
    get: function() {
      return this.getNativeControl().disabled;
    },
    set: function(disabled) {
      this.foundation.setDisabled(disabled);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCCheckbox2.prototype, "value", {
    get: function() {
      return this.getNativeControl().value;
    },
    set: function(value) {
      this.getNativeControl().value = value;
    },
    enumerable: false,
    configurable: true
  });
  MDCCheckbox2.prototype.initialize = function() {
    var DATA_INDETERMINATE_ATTR = strings.DATA_INDETERMINATE_ATTR;
    this.getNativeControl().indeterminate = this.getNativeControl().getAttribute(DATA_INDETERMINATE_ATTR) === "true";
    this.getNativeControl().removeAttribute(DATA_INDETERMINATE_ATTR);
  };
  MDCCheckbox2.prototype.initialSyncWithDOM = function() {
    var _this = this;
    this.handleChange = function() {
      _this.foundation.handleChange();
    };
    this.handleAnimationEnd = function() {
      _this.foundation.handleAnimationEnd();
    };
    this.getNativeControl().addEventListener("change", this.handleChange);
    this.listen(getCorrectEventName(window, "animationend"), this.handleAnimationEnd);
    this.installPropertyChangeHooks();
  };
  MDCCheckbox2.prototype.destroy = function() {
    this.rippleSurface.destroy();
    this.getNativeControl().removeEventListener("change", this.handleChange);
    this.unlisten(getCorrectEventName(window, "animationend"), this.handleAnimationEnd);
    this.uninstallPropertyChangeHooks();
    _super.prototype.destroy.call(this);
  };
  MDCCheckbox2.prototype.getDefaultFoundation = function() {
    var _this = this;
    var adapter = {
      addClass: function(className) {
        return _this.root.classList.add(className);
      },
      forceLayout: function() {
        return _this.root.offsetWidth;
      },
      hasNativeControl: function() {
        return !!_this.getNativeControl();
      },
      isAttachedToDOM: function() {
        return Boolean(_this.root.parentNode);
      },
      isChecked: function() {
        return _this.checked;
      },
      isIndeterminate: function() {
        return _this.indeterminate;
      },
      removeClass: function(className) {
        _this.root.classList.remove(className);
      },
      removeNativeControlAttr: function(attr) {
        _this.getNativeControl().removeAttribute(attr);
      },
      setNativeControlAttr: function(attr, value) {
        _this.getNativeControl().setAttribute(attr, value);
      },
      setNativeControlDisabled: function(disabled) {
        _this.getNativeControl().disabled = disabled;
      }
    };
    return new MDCCheckboxFoundation(adapter);
  };
  MDCCheckbox2.prototype.createRipple = function() {
    var _this = this;
    var adapter = __assign(__assign({}, MDCRipple.createAdapter(this)), { deregisterInteractionHandler: function(evtType, handler) {
      _this.getNativeControl().removeEventListener(evtType, handler, applyPassive());
    }, isSurfaceActive: function() {
      return matches(_this.getNativeControl(), ":active");
    }, isUnbounded: function() {
      return true;
    }, registerInteractionHandler: function(evtType, handler) {
      _this.getNativeControl().addEventListener(evtType, handler, applyPassive());
    } });
    return new MDCRipple(this.root, new MDCRippleFoundation(adapter));
  };
  MDCCheckbox2.prototype.installPropertyChangeHooks = function() {
    var e_1, _a;
    var _this = this;
    var nativeCb = this.getNativeControl();
    var cbProto = Object.getPrototypeOf(nativeCb);
    var _loop_1 = /* @__PURE__ */ __name(function(controlState2) {
      var desc = Object.getOwnPropertyDescriptor(cbProto, controlState2);
      if (!validDescriptor(desc)) {
        return { value: void 0 };
      }
      var nativeGetter = desc.get;
      var nativeCbDesc = {
        configurable: desc.configurable,
        enumerable: desc.enumerable,
        get: nativeGetter,
        set: function(state) {
          desc.set.call(nativeCb, state);
          _this.foundation.handleChange();
        }
      };
      Object.defineProperty(nativeCb, controlState2, nativeCbDesc);
    }, "_loop_1");
    try {
      for (var CB_PROTO_PROPS_1 = __values(CB_PROTO_PROPS), CB_PROTO_PROPS_1_1 = CB_PROTO_PROPS_1.next(); !CB_PROTO_PROPS_1_1.done; CB_PROTO_PROPS_1_1 = CB_PROTO_PROPS_1.next()) {
        var controlState = CB_PROTO_PROPS_1_1.value;
        var state_1 = _loop_1(controlState);
        if (typeof state_1 === "object")
          return state_1.value;
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (CB_PROTO_PROPS_1_1 && !CB_PROTO_PROPS_1_1.done && (_a = CB_PROTO_PROPS_1.return))
          _a.call(CB_PROTO_PROPS_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  };
  MDCCheckbox2.prototype.uninstallPropertyChangeHooks = function() {
    var e_2, _a;
    var nativeCb = this.getNativeControl();
    var cbProto = Object.getPrototypeOf(nativeCb);
    try {
      for (var CB_PROTO_PROPS_2 = __values(CB_PROTO_PROPS), CB_PROTO_PROPS_2_1 = CB_PROTO_PROPS_2.next(); !CB_PROTO_PROPS_2_1.done; CB_PROTO_PROPS_2_1 = CB_PROTO_PROPS_2.next()) {
        var controlState = CB_PROTO_PROPS_2_1.value;
        var desc = Object.getOwnPropertyDescriptor(cbProto, controlState);
        if (!validDescriptor(desc)) {
          return;
        }
        Object.defineProperty(nativeCb, controlState, desc);
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (CB_PROTO_PROPS_2_1 && !CB_PROTO_PROPS_2_1.done && (_a = CB_PROTO_PROPS_2.return))
          _a.call(CB_PROTO_PROPS_2);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
  };
  MDCCheckbox2.prototype.getNativeControl = function() {
    var NATIVE_CONTROL_SELECTOR = strings.NATIVE_CONTROL_SELECTOR;
    var el = this.root.querySelector(NATIVE_CONTROL_SELECTOR);
    if (!el) {
      throw new Error("Checkbox component requires a " + NATIVE_CONTROL_SELECTOR + " element");
    }
    return el;
  };
  return MDCCheckbox2;
}(MDCComponent);
function validDescriptor(inputPropDesc) {
  return !!inputPropDesc && typeof inputPropDesc.set === "function";
}
__name(validDescriptor, "validDescriptor");
export {
  MDCCheckbox,
  MDCCheckboxFoundation,
  cssClasses,
  numbers,
  strings
};
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
//# sourceMappingURL=@material_checkbox.js.map
