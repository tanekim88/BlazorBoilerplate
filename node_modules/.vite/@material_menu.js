import {
  getCorrectPropertyName
} from "./chunk-R23S4P3V.js";
import {
  MDCList,
  MDCListFoundation,
  cssClasses,
  numbers
} from "./chunk-P2YSQX2C.js";
import {
  closest
} from "./chunk-WYKVOA7L.js";
import {
  MDCComponent,
  MDCFoundation,
  __assign,
  __extends,
  __name,
  __values
} from "./chunk-M3SJFXWQ.js";

// node_modules/@material/menu-surface/constants.js
var cssClasses2 = {
  ANCHOR: "mdc-menu-surface--anchor",
  ANIMATING_CLOSED: "mdc-menu-surface--animating-closed",
  ANIMATING_OPEN: "mdc-menu-surface--animating-open",
  FIXED: "mdc-menu-surface--fixed",
  IS_OPEN_BELOW: "mdc-menu-surface--is-open-below",
  OPEN: "mdc-menu-surface--open",
  ROOT: "mdc-menu-surface"
};
var strings = {
  CLOSED_EVENT: "MDCMenuSurface:closed",
  CLOSING_EVENT: "MDCMenuSurface:closing",
  OPENED_EVENT: "MDCMenuSurface:opened",
  FOCUSABLE_ELEMENTS: [
    "button:not(:disabled)",
    '[href]:not([aria-disabled="true"])',
    "input:not(:disabled)",
    "select:not(:disabled)",
    "textarea:not(:disabled)",
    '[tabindex]:not([tabindex="-1"]):not([aria-disabled="true"])'
  ].join(", ")
};
var numbers2 = {
  TRANSITION_OPEN_DURATION: 120,
  TRANSITION_CLOSE_DURATION: 75,
  MARGIN_TO_EDGE: 32,
  ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO: 0.67,
  TOUCH_EVENT_WAIT_MS: 30
};
var CornerBit;
(function(CornerBit2) {
  CornerBit2[CornerBit2["BOTTOM"] = 1] = "BOTTOM";
  CornerBit2[CornerBit2["CENTER"] = 2] = "CENTER";
  CornerBit2[CornerBit2["RIGHT"] = 4] = "RIGHT";
  CornerBit2[CornerBit2["FLIP_RTL"] = 8] = "FLIP_RTL";
})(CornerBit || (CornerBit = {}));
var Corner;
(function(Corner2) {
  Corner2[Corner2["TOP_LEFT"] = 0] = "TOP_LEFT";
  Corner2[Corner2["TOP_RIGHT"] = 4] = "TOP_RIGHT";
  Corner2[Corner2["BOTTOM_LEFT"] = 1] = "BOTTOM_LEFT";
  Corner2[Corner2["BOTTOM_RIGHT"] = 5] = "BOTTOM_RIGHT";
  Corner2[Corner2["TOP_START"] = 8] = "TOP_START";
  Corner2[Corner2["TOP_END"] = 12] = "TOP_END";
  Corner2[Corner2["BOTTOM_START"] = 9] = "BOTTOM_START";
  Corner2[Corner2["BOTTOM_END"] = 13] = "BOTTOM_END";
})(Corner || (Corner = {}));

// node_modules/@material/menu-surface/foundation.js
var MDCMenuSurfaceFoundation = function(_super) {
  __extends(MDCMenuSurfaceFoundation2, _super);
  function MDCMenuSurfaceFoundation2(adapter) {
    var _this = _super.call(this, __assign(__assign({}, MDCMenuSurfaceFoundation2.defaultAdapter), adapter)) || this;
    _this.isSurfaceOpen = false;
    _this.isQuickOpen = false;
    _this.isHoistedElement = false;
    _this.isFixedPosition = false;
    _this.isHorizontallyCenteredOnViewport = false;
    _this.maxHeight = 0;
    _this.openAnimationEndTimerId = 0;
    _this.closeAnimationEndTimerId = 0;
    _this.animationRequestId = 0;
    _this.anchorCorner = Corner.TOP_START;
    _this.originCorner = Corner.TOP_START;
    _this.anchorMargin = { top: 0, right: 0, bottom: 0, left: 0 };
    _this.position = { x: 0, y: 0 };
    return _this;
  }
  __name(MDCMenuSurfaceFoundation2, "MDCMenuSurfaceFoundation");
  Object.defineProperty(MDCMenuSurfaceFoundation2, "cssClasses", {
    get: function() {
      return cssClasses2;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCMenuSurfaceFoundation2, "strings", {
    get: function() {
      return strings;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCMenuSurfaceFoundation2, "numbers", {
    get: function() {
      return numbers2;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCMenuSurfaceFoundation2, "Corner", {
    get: function() {
      return Corner;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCMenuSurfaceFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClass: function() {
          return void 0;
        },
        removeClass: function() {
          return void 0;
        },
        hasClass: function() {
          return false;
        },
        hasAnchor: function() {
          return false;
        },
        isElementInContainer: function() {
          return false;
        },
        isFocused: function() {
          return false;
        },
        isRtl: function() {
          return false;
        },
        getInnerDimensions: function() {
          return { height: 0, width: 0 };
        },
        getAnchorDimensions: function() {
          return null;
        },
        getWindowDimensions: function() {
          return { height: 0, width: 0 };
        },
        getBodyDimensions: function() {
          return { height: 0, width: 0 };
        },
        getWindowScroll: function() {
          return { x: 0, y: 0 };
        },
        setPosition: function() {
          return void 0;
        },
        setMaxHeight: function() {
          return void 0;
        },
        setTransformOrigin: function() {
          return void 0;
        },
        saveFocus: function() {
          return void 0;
        },
        restoreFocus: function() {
          return void 0;
        },
        notifyClose: function() {
          return void 0;
        },
        notifyOpen: function() {
          return void 0;
        },
        notifyClosing: function() {
          return void 0;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCMenuSurfaceFoundation2.prototype.init = function() {
    var _a = MDCMenuSurfaceFoundation2.cssClasses, ROOT = _a.ROOT, OPEN = _a.OPEN;
    if (!this.adapter.hasClass(ROOT)) {
      throw new Error(ROOT + " class required in root element.");
    }
    if (this.adapter.hasClass(OPEN)) {
      this.isSurfaceOpen = true;
    }
  };
  MDCMenuSurfaceFoundation2.prototype.destroy = function() {
    clearTimeout(this.openAnimationEndTimerId);
    clearTimeout(this.closeAnimationEndTimerId);
    cancelAnimationFrame(this.animationRequestId);
  };
  MDCMenuSurfaceFoundation2.prototype.setAnchorCorner = function(corner) {
    this.anchorCorner = corner;
  };
  MDCMenuSurfaceFoundation2.prototype.flipCornerHorizontally = function() {
    this.originCorner = this.originCorner ^ CornerBit.RIGHT;
  };
  MDCMenuSurfaceFoundation2.prototype.setAnchorMargin = function(margin) {
    this.anchorMargin.top = margin.top || 0;
    this.anchorMargin.right = margin.right || 0;
    this.anchorMargin.bottom = margin.bottom || 0;
    this.anchorMargin.left = margin.left || 0;
  };
  MDCMenuSurfaceFoundation2.prototype.setIsHoisted = function(isHoisted) {
    this.isHoistedElement = isHoisted;
  };
  MDCMenuSurfaceFoundation2.prototype.setFixedPosition = function(isFixedPosition) {
    this.isFixedPosition = isFixedPosition;
  };
  MDCMenuSurfaceFoundation2.prototype.isFixed = function() {
    return this.isFixedPosition;
  };
  MDCMenuSurfaceFoundation2.prototype.setAbsolutePosition = function(x, y) {
    this.position.x = this.isFinite(x) ? x : 0;
    this.position.y = this.isFinite(y) ? y : 0;
  };
  MDCMenuSurfaceFoundation2.prototype.setIsHorizontallyCenteredOnViewport = function(isCentered) {
    this.isHorizontallyCenteredOnViewport = isCentered;
  };
  MDCMenuSurfaceFoundation2.prototype.setQuickOpen = function(quickOpen) {
    this.isQuickOpen = quickOpen;
  };
  MDCMenuSurfaceFoundation2.prototype.setMaxHeight = function(maxHeight) {
    this.maxHeight = maxHeight;
  };
  MDCMenuSurfaceFoundation2.prototype.isOpen = function() {
    return this.isSurfaceOpen;
  };
  MDCMenuSurfaceFoundation2.prototype.open = function() {
    var _this = this;
    if (this.isSurfaceOpen) {
      return;
    }
    this.adapter.saveFocus();
    if (this.isQuickOpen) {
      this.isSurfaceOpen = true;
      this.adapter.addClass(MDCMenuSurfaceFoundation2.cssClasses.OPEN);
      this.dimensions = this.adapter.getInnerDimensions();
      this.autoposition();
      this.adapter.notifyOpen();
    } else {
      this.adapter.addClass(MDCMenuSurfaceFoundation2.cssClasses.ANIMATING_OPEN);
      this.animationRequestId = requestAnimationFrame(function() {
        _this.dimensions = _this.adapter.getInnerDimensions();
        _this.autoposition();
        _this.adapter.addClass(MDCMenuSurfaceFoundation2.cssClasses.OPEN);
        _this.openAnimationEndTimerId = setTimeout(function() {
          _this.openAnimationEndTimerId = 0;
          _this.adapter.removeClass(MDCMenuSurfaceFoundation2.cssClasses.ANIMATING_OPEN);
          _this.adapter.notifyOpen();
        }, numbers2.TRANSITION_OPEN_DURATION);
      });
      this.isSurfaceOpen = true;
    }
  };
  MDCMenuSurfaceFoundation2.prototype.close = function(skipRestoreFocus) {
    var _this = this;
    if (skipRestoreFocus === void 0) {
      skipRestoreFocus = false;
    }
    if (!this.isSurfaceOpen) {
      return;
    }
    this.adapter.notifyClosing();
    if (this.isQuickOpen) {
      this.isSurfaceOpen = false;
      if (!skipRestoreFocus) {
        this.maybeRestoreFocus();
      }
      this.adapter.removeClass(MDCMenuSurfaceFoundation2.cssClasses.OPEN);
      this.adapter.removeClass(MDCMenuSurfaceFoundation2.cssClasses.IS_OPEN_BELOW);
      this.adapter.notifyClose();
      return;
    }
    this.adapter.addClass(MDCMenuSurfaceFoundation2.cssClasses.ANIMATING_CLOSED);
    requestAnimationFrame(function() {
      _this.adapter.removeClass(MDCMenuSurfaceFoundation2.cssClasses.OPEN);
      _this.adapter.removeClass(MDCMenuSurfaceFoundation2.cssClasses.IS_OPEN_BELOW);
      _this.closeAnimationEndTimerId = setTimeout(function() {
        _this.closeAnimationEndTimerId = 0;
        _this.adapter.removeClass(MDCMenuSurfaceFoundation2.cssClasses.ANIMATING_CLOSED);
        _this.adapter.notifyClose();
      }, numbers2.TRANSITION_CLOSE_DURATION);
    });
    this.isSurfaceOpen = false;
    if (!skipRestoreFocus) {
      this.maybeRestoreFocus();
    }
  };
  MDCMenuSurfaceFoundation2.prototype.handleBodyClick = function(evt) {
    var el = evt.target;
    if (this.adapter.isElementInContainer(el)) {
      return;
    }
    this.close();
  };
  MDCMenuSurfaceFoundation2.prototype.handleKeydown = function(evt) {
    var keyCode = evt.keyCode, key = evt.key;
    var isEscape = key === "Escape" || keyCode === 27;
    if (isEscape) {
      this.close();
    }
  };
  MDCMenuSurfaceFoundation2.prototype.autoposition = function() {
    var _a;
    this.measurements = this.getAutoLayoutmeasurements();
    var corner = this.getoriginCorner();
    var maxMenuSurfaceHeight = this.getMenuSurfaceMaxHeight(corner);
    var verticalAlignment = this.hasBit(corner, CornerBit.BOTTOM) ? "bottom" : "top";
    var horizontalAlignment = this.hasBit(corner, CornerBit.RIGHT) ? "right" : "left";
    var horizontalOffset = this.getHorizontalOriginOffset(corner);
    var verticalOffset = this.getVerticalOriginOffset(corner);
    var _b = this.measurements, anchorSize = _b.anchorSize, surfaceSize = _b.surfaceSize;
    var position = (_a = {}, _a[horizontalAlignment] = horizontalOffset, _a[verticalAlignment] = verticalOffset, _a);
    if (anchorSize.width / surfaceSize.width > numbers2.ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO) {
      horizontalAlignment = "center";
    }
    if (this.isHoistedElement || this.isFixedPosition) {
      this.adjustPositionForHoistedElement(position);
    }
    this.adapter.setTransformOrigin(horizontalAlignment + " " + verticalAlignment);
    this.adapter.setPosition(position);
    this.adapter.setMaxHeight(maxMenuSurfaceHeight ? maxMenuSurfaceHeight + "px" : "");
    if (!this.hasBit(corner, CornerBit.BOTTOM)) {
      this.adapter.addClass(MDCMenuSurfaceFoundation2.cssClasses.IS_OPEN_BELOW);
    }
  };
  MDCMenuSurfaceFoundation2.prototype.getAutoLayoutmeasurements = function() {
    var anchorRect = this.adapter.getAnchorDimensions();
    var bodySize = this.adapter.getBodyDimensions();
    var viewportSize = this.adapter.getWindowDimensions();
    var windowScroll = this.adapter.getWindowScroll();
    if (!anchorRect) {
      anchorRect = {
        top: this.position.y,
        right: this.position.x,
        bottom: this.position.y,
        left: this.position.x,
        width: 0,
        height: 0
      };
    }
    return {
      anchorSize: anchorRect,
      bodySize,
      surfaceSize: this.dimensions,
      viewportDistance: {
        top: anchorRect.top,
        right: viewportSize.width - anchorRect.right,
        bottom: viewportSize.height - anchorRect.bottom,
        left: anchorRect.left
      },
      viewportSize,
      windowScroll
    };
  };
  MDCMenuSurfaceFoundation2.prototype.getoriginCorner = function() {
    var corner = this.originCorner;
    var _a = this.measurements, viewportDistance = _a.viewportDistance, anchorSize = _a.anchorSize, surfaceSize = _a.surfaceSize;
    var MARGIN_TO_EDGE = MDCMenuSurfaceFoundation2.numbers.MARGIN_TO_EDGE;
    var isAnchoredToBottom = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);
    var availableTop;
    var availableBottom;
    if (isAnchoredToBottom) {
      availableTop = viewportDistance.top - MARGIN_TO_EDGE + this.anchorMargin.bottom;
      availableBottom = viewportDistance.bottom - MARGIN_TO_EDGE - this.anchorMargin.bottom;
    } else {
      availableTop = viewportDistance.top - MARGIN_TO_EDGE + this.anchorMargin.top;
      availableBottom = viewportDistance.bottom - MARGIN_TO_EDGE + anchorSize.height - this.anchorMargin.top;
    }
    var isAvailableBottom = availableBottom - surfaceSize.height > 0;
    if (!isAvailableBottom && availableTop > availableBottom) {
      corner = this.setBit(corner, CornerBit.BOTTOM);
    }
    var isRtl = this.adapter.isRtl();
    var isFlipRtl = this.hasBit(this.anchorCorner, CornerBit.FLIP_RTL);
    var hasRightBit = this.hasBit(this.anchorCorner, CornerBit.RIGHT) || this.hasBit(corner, CornerBit.RIGHT);
    var isAnchoredToRight = false;
    if (isRtl && isFlipRtl) {
      isAnchoredToRight = !hasRightBit;
    } else {
      isAnchoredToRight = hasRightBit;
    }
    var availableLeft;
    var availableRight;
    if (isAnchoredToRight) {
      availableLeft = viewportDistance.left + anchorSize.width + this.anchorMargin.right;
      availableRight = viewportDistance.right - this.anchorMargin.right;
    } else {
      availableLeft = viewportDistance.left + this.anchorMargin.left;
      availableRight = viewportDistance.right + anchorSize.width - this.anchorMargin.left;
    }
    var isAvailableLeft = availableLeft - surfaceSize.width > 0;
    var isAvailableRight = availableRight - surfaceSize.width > 0;
    var isOriginCornerAlignedToEnd = this.hasBit(corner, CornerBit.FLIP_RTL) && this.hasBit(corner, CornerBit.RIGHT);
    if (isAvailableRight && isOriginCornerAlignedToEnd && isRtl || !isAvailableLeft && isOriginCornerAlignedToEnd) {
      corner = this.unsetBit(corner, CornerBit.RIGHT);
    } else if (isAvailableLeft && isAnchoredToRight && isRtl || isAvailableLeft && !isAnchoredToRight && hasRightBit || !isAvailableRight && availableLeft >= availableRight) {
      corner = this.setBit(corner, CornerBit.RIGHT);
    }
    return corner;
  };
  MDCMenuSurfaceFoundation2.prototype.getMenuSurfaceMaxHeight = function(corner) {
    if (this.maxHeight > 0) {
      return this.maxHeight;
    }
    var viewportDistance = this.measurements.viewportDistance;
    var maxHeight = 0;
    var isBottomAligned = this.hasBit(corner, CornerBit.BOTTOM);
    var isBottomAnchored = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);
    var MARGIN_TO_EDGE = MDCMenuSurfaceFoundation2.numbers.MARGIN_TO_EDGE;
    if (isBottomAligned) {
      maxHeight = viewportDistance.top + this.anchorMargin.top - MARGIN_TO_EDGE;
      if (!isBottomAnchored) {
        maxHeight += this.measurements.anchorSize.height;
      }
    } else {
      maxHeight = viewportDistance.bottom - this.anchorMargin.bottom + this.measurements.anchorSize.height - MARGIN_TO_EDGE;
      if (isBottomAnchored) {
        maxHeight -= this.measurements.anchorSize.height;
      }
    }
    return maxHeight;
  };
  MDCMenuSurfaceFoundation2.prototype.getHorizontalOriginOffset = function(corner) {
    var anchorSize = this.measurements.anchorSize;
    var isRightAligned = this.hasBit(corner, CornerBit.RIGHT);
    var avoidHorizontalOverlap = this.hasBit(this.anchorCorner, CornerBit.RIGHT);
    if (isRightAligned) {
      var rightOffset = avoidHorizontalOverlap ? anchorSize.width - this.anchorMargin.left : this.anchorMargin.right;
      if (this.isHoistedElement || this.isFixedPosition) {
        return rightOffset - (this.measurements.viewportSize.width - this.measurements.bodySize.width);
      }
      return rightOffset;
    }
    return avoidHorizontalOverlap ? anchorSize.width - this.anchorMargin.right : this.anchorMargin.left;
  };
  MDCMenuSurfaceFoundation2.prototype.getVerticalOriginOffset = function(corner) {
    var anchorSize = this.measurements.anchorSize;
    var isBottomAligned = this.hasBit(corner, CornerBit.BOTTOM);
    var avoidVerticalOverlap = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);
    var y = 0;
    if (isBottomAligned) {
      y = avoidVerticalOverlap ? anchorSize.height - this.anchorMargin.top : -this.anchorMargin.bottom;
    } else {
      y = avoidVerticalOverlap ? anchorSize.height + this.anchorMargin.bottom : this.anchorMargin.top;
    }
    return y;
  };
  MDCMenuSurfaceFoundation2.prototype.adjustPositionForHoistedElement = function(position) {
    var e_1, _a;
    var _b = this.measurements, windowScroll = _b.windowScroll, viewportDistance = _b.viewportDistance, surfaceSize = _b.surfaceSize, viewportSize = _b.viewportSize;
    var props = Object.keys(position);
    try {
      for (var props_1 = __values(props), props_1_1 = props_1.next(); !props_1_1.done; props_1_1 = props_1.next()) {
        var prop = props_1_1.value;
        var value = position[prop] || 0;
        if (this.isHorizontallyCenteredOnViewport && (prop === "left" || prop === "right")) {
          position[prop] = (viewportSize.width - surfaceSize.width) / 2;
          continue;
        }
        value += viewportDistance[prop];
        if (!this.isFixedPosition) {
          if (prop === "top") {
            value += windowScroll.y;
          } else if (prop === "bottom") {
            value -= windowScroll.y;
          } else if (prop === "left") {
            value += windowScroll.x;
          } else {
            value -= windowScroll.x;
          }
        }
        position[prop] = value;
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (props_1_1 && !props_1_1.done && (_a = props_1.return))
          _a.call(props_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  };
  MDCMenuSurfaceFoundation2.prototype.maybeRestoreFocus = function() {
    var _this = this;
    var isRootFocused = this.adapter.isFocused();
    var childHasFocus = document.activeElement && this.adapter.isElementInContainer(document.activeElement);
    if (isRootFocused || childHasFocus) {
      setTimeout(function() {
        _this.adapter.restoreFocus();
      }, numbers2.TOUCH_EVENT_WAIT_MS);
    }
  };
  MDCMenuSurfaceFoundation2.prototype.hasBit = function(corner, bit) {
    return Boolean(corner & bit);
  };
  MDCMenuSurfaceFoundation2.prototype.setBit = function(corner, bit) {
    return corner | bit;
  };
  MDCMenuSurfaceFoundation2.prototype.unsetBit = function(corner, bit) {
    return corner ^ bit;
  };
  MDCMenuSurfaceFoundation2.prototype.isFinite = function(num) {
    return typeof num === "number" && isFinite(num);
  };
  return MDCMenuSurfaceFoundation2;
}(MDCFoundation);

// node_modules/@material/menu-surface/component.js
var MDCMenuSurface = function(_super) {
  __extends(MDCMenuSurface2, _super);
  function MDCMenuSurface2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  __name(MDCMenuSurface2, "MDCMenuSurface");
  MDCMenuSurface2.attachTo = function(root) {
    return new MDCMenuSurface2(root);
  };
  MDCMenuSurface2.prototype.initialSyncWithDOM = function() {
    var _this = this;
    var parentEl = this.root.parentElement;
    this.anchorElement = parentEl && parentEl.classList.contains(cssClasses2.ANCHOR) ? parentEl : null;
    if (this.root.classList.contains(cssClasses2.FIXED)) {
      this.setFixedPosition(true);
    }
    this.handleKeydown = function(event) {
      _this.foundation.handleKeydown(event);
    };
    this.handleBodyClick = function(event) {
      _this.foundation.handleBodyClick(event);
    };
    this.registerBodyClickListener = function() {
      document.body.addEventListener("click", _this.handleBodyClick, { capture: true });
    };
    this.deregisterBodyClickListener = function() {
      document.body.removeEventListener("click", _this.handleBodyClick, { capture: true });
    };
    this.listen("keydown", this.handleKeydown);
    this.listen(strings.OPENED_EVENT, this.registerBodyClickListener);
    this.listen(strings.CLOSED_EVENT, this.deregisterBodyClickListener);
  };
  MDCMenuSurface2.prototype.destroy = function() {
    this.unlisten("keydown", this.handleKeydown);
    this.unlisten(strings.OPENED_EVENT, this.registerBodyClickListener);
    this.unlisten(strings.CLOSED_EVENT, this.deregisterBodyClickListener);
    _super.prototype.destroy.call(this);
  };
  MDCMenuSurface2.prototype.isOpen = function() {
    return this.foundation.isOpen();
  };
  MDCMenuSurface2.prototype.open = function() {
    this.foundation.open();
  };
  MDCMenuSurface2.prototype.close = function(skipRestoreFocus) {
    if (skipRestoreFocus === void 0) {
      skipRestoreFocus = false;
    }
    this.foundation.close(skipRestoreFocus);
  };
  Object.defineProperty(MDCMenuSurface2.prototype, "quickOpen", {
    set: function(quickOpen) {
      this.foundation.setQuickOpen(quickOpen);
    },
    enumerable: false,
    configurable: true
  });
  MDCMenuSurface2.prototype.setIsHoisted = function(isHoisted) {
    this.foundation.setIsHoisted(isHoisted);
  };
  MDCMenuSurface2.prototype.setMenuSurfaceAnchorElement = function(element) {
    this.anchorElement = element;
  };
  MDCMenuSurface2.prototype.setFixedPosition = function(isFixed) {
    if (isFixed) {
      this.root.classList.add(cssClasses2.FIXED);
    } else {
      this.root.classList.remove(cssClasses2.FIXED);
    }
    this.foundation.setFixedPosition(isFixed);
  };
  MDCMenuSurface2.prototype.setAbsolutePosition = function(x, y) {
    this.foundation.setAbsolutePosition(x, y);
    this.setIsHoisted(true);
  };
  MDCMenuSurface2.prototype.setAnchorCorner = function(corner) {
    this.foundation.setAnchorCorner(corner);
  };
  MDCMenuSurface2.prototype.setAnchorMargin = function(margin) {
    this.foundation.setAnchorMargin(margin);
  };
  MDCMenuSurface2.prototype.getDefaultFoundation = function() {
    var _this = this;
    var adapter = {
      addClass: function(className) {
        return _this.root.classList.add(className);
      },
      removeClass: function(className) {
        return _this.root.classList.remove(className);
      },
      hasClass: function(className) {
        return _this.root.classList.contains(className);
      },
      hasAnchor: function() {
        return !!_this.anchorElement;
      },
      notifyClose: function() {
        return _this.emit(MDCMenuSurfaceFoundation.strings.CLOSED_EVENT, {});
      },
      notifyClosing: function() {
        _this.emit(MDCMenuSurfaceFoundation.strings.CLOSING_EVENT, {});
      },
      notifyOpen: function() {
        return _this.emit(MDCMenuSurfaceFoundation.strings.OPENED_EVENT, {});
      },
      isElementInContainer: function(el) {
        return _this.root.contains(el);
      },
      isRtl: function() {
        return getComputedStyle(_this.root).getPropertyValue("direction") === "rtl";
      },
      setTransformOrigin: function(origin) {
        var propertyName = getCorrectPropertyName(window, "transform") + "-origin";
        _this.root.style.setProperty(propertyName, origin);
      },
      isFocused: function() {
        return document.activeElement === _this.root;
      },
      saveFocus: function() {
        _this.previousFocus = document.activeElement;
      },
      restoreFocus: function() {
        if (_this.root.contains(document.activeElement)) {
          if (_this.previousFocus && _this.previousFocus.focus) {
            _this.previousFocus.focus();
          }
        }
      },
      getInnerDimensions: function() {
        return {
          width: _this.root.offsetWidth,
          height: _this.root.offsetHeight
        };
      },
      getAnchorDimensions: function() {
        return _this.anchorElement ? _this.anchorElement.getBoundingClientRect() : null;
      },
      getWindowDimensions: function() {
        return { width: window.innerWidth, height: window.innerHeight };
      },
      getBodyDimensions: function() {
        return { width: document.body.clientWidth, height: document.body.clientHeight };
      },
      getWindowScroll: function() {
        return { x: window.pageXOffset, y: window.pageYOffset };
      },
      setPosition: function(position) {
        var rootHTML = _this.root;
        rootHTML.style.left = "left" in position ? position.left + "px" : "";
        rootHTML.style.right = "right" in position ? position.right + "px" : "";
        rootHTML.style.top = "top" in position ? position.top + "px" : "";
        rootHTML.style.bottom = "bottom" in position ? position.bottom + "px" : "";
      },
      setMaxHeight: function(height) {
        _this.root.style.maxHeight = height;
      }
    };
    return new MDCMenuSurfaceFoundation(adapter);
  };
  return MDCMenuSurface2;
}(MDCComponent);

// node_modules/@material/menu/constants.js
var cssClasses3 = {
  MENU_SELECTED_LIST_ITEM: "mdc-menu-item--selected",
  MENU_SELECTION_GROUP: "mdc-menu__selection-group",
  ROOT: "mdc-menu"
};
var strings2 = {
  ARIA_CHECKED_ATTR: "aria-checked",
  ARIA_DISABLED_ATTR: "aria-disabled",
  CHECKBOX_SELECTOR: 'input[type="checkbox"]',
  LIST_SELECTOR: ".mdc-list,.mdc-deprecated-list",
  SELECTED_EVENT: "MDCMenu:selected",
  SKIP_RESTORE_FOCUS: "data-menu-item-skip-restore-focus"
};
var numbers3 = {
  FOCUS_ROOT_INDEX: -1
};
var DefaultFocusState;
(function(DefaultFocusState2) {
  DefaultFocusState2[DefaultFocusState2["NONE"] = 0] = "NONE";
  DefaultFocusState2[DefaultFocusState2["LIST_ROOT"] = 1] = "LIST_ROOT";
  DefaultFocusState2[DefaultFocusState2["FIRST_ITEM"] = 2] = "FIRST_ITEM";
  DefaultFocusState2[DefaultFocusState2["LAST_ITEM"] = 3] = "LAST_ITEM";
})(DefaultFocusState || (DefaultFocusState = {}));

// node_modules/@material/menu/foundation.js
var MDCMenuFoundation = function(_super) {
  __extends(MDCMenuFoundation2, _super);
  function MDCMenuFoundation2(adapter) {
    var _this = _super.call(this, __assign(__assign({}, MDCMenuFoundation2.defaultAdapter), adapter)) || this;
    _this.closeAnimationEndTimerId = 0;
    _this.defaultFocusState = DefaultFocusState.LIST_ROOT;
    _this.selectedIndex = -1;
    return _this;
  }
  __name(MDCMenuFoundation2, "MDCMenuFoundation");
  Object.defineProperty(MDCMenuFoundation2, "cssClasses", {
    get: function() {
      return cssClasses3;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCMenuFoundation2, "strings", {
    get: function() {
      return strings2;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCMenuFoundation2, "numbers", {
    get: function() {
      return numbers3;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCMenuFoundation2, "defaultAdapter", {
    get: function() {
      return {
        addClassToElementAtIndex: function() {
          return void 0;
        },
        removeClassFromElementAtIndex: function() {
          return void 0;
        },
        addAttributeToElementAtIndex: function() {
          return void 0;
        },
        removeAttributeFromElementAtIndex: function() {
          return void 0;
        },
        getAttributeFromElementAtIndex: function() {
          return null;
        },
        elementContainsClass: function() {
          return false;
        },
        closeSurface: function() {
          return void 0;
        },
        getElementIndex: function() {
          return -1;
        },
        notifySelected: function() {
          return void 0;
        },
        getMenuItemCount: function() {
          return 0;
        },
        focusItemAtIndex: function() {
          return void 0;
        },
        focusListRoot: function() {
          return void 0;
        },
        getSelectedSiblingOfItemAtIndex: function() {
          return -1;
        },
        isSelectableItemAtIndex: function() {
          return false;
        }
      };
    },
    enumerable: false,
    configurable: true
  });
  MDCMenuFoundation2.prototype.destroy = function() {
    if (this.closeAnimationEndTimerId) {
      clearTimeout(this.closeAnimationEndTimerId);
    }
    this.adapter.closeSurface();
  };
  MDCMenuFoundation2.prototype.handleKeydown = function(evt) {
    var key = evt.key, keyCode = evt.keyCode;
    var isTab = key === "Tab" || keyCode === 9;
    if (isTab) {
      this.adapter.closeSurface(true);
    }
  };
  MDCMenuFoundation2.prototype.handleItemAction = function(listItem) {
    var _this = this;
    var index = this.adapter.getElementIndex(listItem);
    if (index < 0) {
      return;
    }
    this.adapter.notifySelected({ index });
    var skipRestoreFocus = this.adapter.getAttributeFromElementAtIndex(index, strings2.SKIP_RESTORE_FOCUS) === "true";
    this.adapter.closeSurface(skipRestoreFocus);
    this.closeAnimationEndTimerId = setTimeout(function() {
      var recomputedIndex = _this.adapter.getElementIndex(listItem);
      if (recomputedIndex >= 0 && _this.adapter.isSelectableItemAtIndex(recomputedIndex)) {
        _this.setSelectedIndex(recomputedIndex);
      }
    }, MDCMenuSurfaceFoundation.numbers.TRANSITION_CLOSE_DURATION);
  };
  MDCMenuFoundation2.prototype.handleMenuSurfaceOpened = function() {
    switch (this.defaultFocusState) {
      case DefaultFocusState.FIRST_ITEM:
        this.adapter.focusItemAtIndex(0);
        break;
      case DefaultFocusState.LAST_ITEM:
        this.adapter.focusItemAtIndex(this.adapter.getMenuItemCount() - 1);
        break;
      case DefaultFocusState.NONE:
        break;
      default:
        this.adapter.focusListRoot();
        break;
    }
  };
  MDCMenuFoundation2.prototype.setDefaultFocusState = function(focusState) {
    this.defaultFocusState = focusState;
  };
  MDCMenuFoundation2.prototype.getSelectedIndex = function() {
    return this.selectedIndex;
  };
  MDCMenuFoundation2.prototype.setSelectedIndex = function(index) {
    this.validatedIndex(index);
    if (!this.adapter.isSelectableItemAtIndex(index)) {
      throw new Error("MDCMenuFoundation: No selection group at specified index.");
    }
    var prevSelectedIndex = this.adapter.getSelectedSiblingOfItemAtIndex(index);
    if (prevSelectedIndex >= 0) {
      this.adapter.removeAttributeFromElementAtIndex(prevSelectedIndex, strings2.ARIA_CHECKED_ATTR);
      this.adapter.removeClassFromElementAtIndex(prevSelectedIndex, cssClasses3.MENU_SELECTED_LIST_ITEM);
    }
    this.adapter.addClassToElementAtIndex(index, cssClasses3.MENU_SELECTED_LIST_ITEM);
    this.adapter.addAttributeToElementAtIndex(index, strings2.ARIA_CHECKED_ATTR, "true");
    this.selectedIndex = index;
  };
  MDCMenuFoundation2.prototype.setEnabled = function(index, isEnabled) {
    this.validatedIndex(index);
    if (isEnabled) {
      this.adapter.removeClassFromElementAtIndex(index, cssClasses.LIST_ITEM_DISABLED_CLASS);
      this.adapter.addAttributeToElementAtIndex(index, strings2.ARIA_DISABLED_ATTR, "false");
    } else {
      this.adapter.addClassToElementAtIndex(index, cssClasses.LIST_ITEM_DISABLED_CLASS);
      this.adapter.addAttributeToElementAtIndex(index, strings2.ARIA_DISABLED_ATTR, "true");
    }
  };
  MDCMenuFoundation2.prototype.validatedIndex = function(index) {
    var menuSize = this.adapter.getMenuItemCount();
    var isIndexInRange = index >= 0 && index < menuSize;
    if (!isIndexInRange) {
      throw new Error("MDCMenuFoundation: No list item at specified index.");
    }
  };
  return MDCMenuFoundation2;
}(MDCFoundation);

// node_modules/@material/menu/component.js
var MDCMenu = function(_super) {
  __extends(MDCMenu2, _super);
  function MDCMenu2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  __name(MDCMenu2, "MDCMenu");
  MDCMenu2.attachTo = function(root) {
    return new MDCMenu2(root);
  };
  MDCMenu2.prototype.initialize = function(menuSurfaceFactory, listFactory) {
    if (menuSurfaceFactory === void 0) {
      menuSurfaceFactory = /* @__PURE__ */ __name(function(el) {
        return new MDCMenuSurface(el);
      }, "menuSurfaceFactory");
    }
    if (listFactory === void 0) {
      listFactory = /* @__PURE__ */ __name(function(el) {
        return new MDCList(el);
      }, "listFactory");
    }
    this.menuSurfaceFactory = menuSurfaceFactory;
    this.listFactory = listFactory;
  };
  MDCMenu2.prototype.initialSyncWithDOM = function() {
    var _this = this;
    this.menuSurface = this.menuSurfaceFactory(this.root);
    var list = this.root.querySelector(strings2.LIST_SELECTOR);
    if (list) {
      this.list = this.listFactory(list);
      this.list.wrapFocus = true;
    } else {
      this.list = null;
    }
    this.handleKeydown = function(evt) {
      _this.foundation.handleKeydown(evt);
    };
    this.handleItemAction = function(evt) {
      _this.foundation.handleItemAction(_this.items[evt.detail.index]);
    };
    this.handleMenuSurfaceOpened = function() {
      _this.foundation.handleMenuSurfaceOpened();
    };
    this.menuSurface.listen(MDCMenuSurfaceFoundation.strings.OPENED_EVENT, this.handleMenuSurfaceOpened);
    this.listen("keydown", this.handleKeydown);
    this.listen(MDCListFoundation.strings.ACTION_EVENT, this.handleItemAction);
  };
  MDCMenu2.prototype.destroy = function() {
    if (this.list) {
      this.list.destroy();
    }
    this.menuSurface.destroy();
    this.menuSurface.unlisten(MDCMenuSurfaceFoundation.strings.OPENED_EVENT, this.handleMenuSurfaceOpened);
    this.unlisten("keydown", this.handleKeydown);
    this.unlisten(MDCListFoundation.strings.ACTION_EVENT, this.handleItemAction);
    _super.prototype.destroy.call(this);
  };
  Object.defineProperty(MDCMenu2.prototype, "open", {
    get: function() {
      return this.menuSurface.isOpen();
    },
    set: function(value) {
      if (value) {
        this.menuSurface.open();
      } else {
        this.menuSurface.close();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCMenu2.prototype, "wrapFocus", {
    get: function() {
      return this.list ? this.list.wrapFocus : false;
    },
    set: function(value) {
      if (this.list) {
        this.list.wrapFocus = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCMenu2.prototype, "hasTypeahead", {
    set: function(value) {
      if (this.list) {
        this.list.hasTypeahead = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCMenu2.prototype, "typeaheadInProgress", {
    get: function() {
      return this.list ? this.list.typeaheadInProgress : false;
    },
    enumerable: false,
    configurable: true
  });
  MDCMenu2.prototype.typeaheadMatchItem = function(nextChar, startingIndex) {
    if (this.list) {
      return this.list.typeaheadMatchItem(nextChar, startingIndex);
    }
    return -1;
  };
  MDCMenu2.prototype.layout = function() {
    if (this.list) {
      this.list.layout();
    }
  };
  Object.defineProperty(MDCMenu2.prototype, "items", {
    get: function() {
      return this.list ? this.list.listElements : [];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCMenu2.prototype, "singleSelection", {
    set: function(singleSelection) {
      if (this.list) {
        this.list.singleSelection = singleSelection;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCMenu2.prototype, "selectedIndex", {
    get: function() {
      return this.list ? this.list.selectedIndex : numbers.UNSET_INDEX;
    },
    set: function(index) {
      if (this.list) {
        this.list.selectedIndex = index;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MDCMenu2.prototype, "quickOpen", {
    set: function(quickOpen) {
      this.menuSurface.quickOpen = quickOpen;
    },
    enumerable: false,
    configurable: true
  });
  MDCMenu2.prototype.setDefaultFocusState = function(focusState) {
    this.foundation.setDefaultFocusState(focusState);
  };
  MDCMenu2.prototype.setAnchorCorner = function(corner) {
    this.menuSurface.setAnchorCorner(corner);
  };
  MDCMenu2.prototype.setAnchorMargin = function(margin) {
    this.menuSurface.setAnchorMargin(margin);
  };
  MDCMenu2.prototype.setSelectedIndex = function(index) {
    this.foundation.setSelectedIndex(index);
  };
  MDCMenu2.prototype.setEnabled = function(index, isEnabled) {
    this.foundation.setEnabled(index, isEnabled);
  };
  MDCMenu2.prototype.getOptionByIndex = function(index) {
    var items = this.items;
    if (index < items.length) {
      return this.items[index];
    } else {
      return null;
    }
  };
  MDCMenu2.prototype.getPrimaryTextAtIndex = function(index) {
    var item = this.getOptionByIndex(index);
    if (item && this.list) {
      return this.list.getPrimaryText(item) || "";
    }
    return "";
  };
  MDCMenu2.prototype.setFixedPosition = function(isFixed) {
    this.menuSurface.setFixedPosition(isFixed);
  };
  MDCMenu2.prototype.setIsHoisted = function(isHoisted) {
    this.menuSurface.setIsHoisted(isHoisted);
  };
  MDCMenu2.prototype.setAbsolutePosition = function(x, y) {
    this.menuSurface.setAbsolutePosition(x, y);
  };
  MDCMenu2.prototype.setAnchorElement = function(element) {
    this.menuSurface.anchorElement = element;
  };
  MDCMenu2.prototype.getDefaultFoundation = function() {
    var _this = this;
    var adapter = {
      addClassToElementAtIndex: function(index, className) {
        var list = _this.items;
        list[index].classList.add(className);
      },
      removeClassFromElementAtIndex: function(index, className) {
        var list = _this.items;
        list[index].classList.remove(className);
      },
      addAttributeToElementAtIndex: function(index, attr, value) {
        var list = _this.items;
        list[index].setAttribute(attr, value);
      },
      removeAttributeFromElementAtIndex: function(index, attr) {
        var list = _this.items;
        list[index].removeAttribute(attr);
      },
      getAttributeFromElementAtIndex: function(index, attr) {
        var list = _this.items;
        return list[index].getAttribute(attr);
      },
      elementContainsClass: function(element, className) {
        return element.classList.contains(className);
      },
      closeSurface: function(skipRestoreFocus) {
        _this.menuSurface.close(skipRestoreFocus);
      },
      getElementIndex: function(element) {
        return _this.items.indexOf(element);
      },
      notifySelected: function(evtData) {
        _this.emit(strings2.SELECTED_EVENT, {
          index: evtData.index,
          item: _this.items[evtData.index]
        });
      },
      getMenuItemCount: function() {
        return _this.items.length;
      },
      focusItemAtIndex: function(index) {
        _this.items[index].focus();
      },
      focusListRoot: function() {
        _this.root.querySelector(strings2.LIST_SELECTOR).focus();
      },
      isSelectableItemAtIndex: function(index) {
        return !!closest(_this.items[index], "." + cssClasses3.MENU_SELECTION_GROUP);
      },
      getSelectedSiblingOfItemAtIndex: function(index) {
        var selectionGroupEl = closest(_this.items[index], "." + cssClasses3.MENU_SELECTION_GROUP);
        var selectedItemEl = selectionGroupEl.querySelector("." + cssClasses3.MENU_SELECTED_LIST_ITEM);
        return selectedItemEl ? _this.items.indexOf(selectedItemEl) : -1;
      }
    };
    return new MDCMenuFoundation(adapter);
  };
  return MDCMenu2;
}(MDCComponent);
export {
  Corner,
  DefaultFocusState,
  MDCMenu,
  MDCMenuFoundation,
  cssClasses3 as cssClasses,
  numbers3 as numbers,
  strings2 as strings
};
/**
 * @license
 * Copyright 2018 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @license
 * Copyright 2019 Google Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
//# sourceMappingURL=@material_menu.js.map
